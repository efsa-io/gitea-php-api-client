<?php
/**
 * IssueApi
 * PHP version 7.2
 *
 * @category Class
 * @package  Efsa\Client\Gitea
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Gitea API.
 *
 * This documentation describes the Gitea API.
 *
 * The version of the OpenAPI document: 1.17.0+dev-334-gf36701c70
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.2.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Efsa\Client\Gitea\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Efsa\Client\Gitea\ApiException;
use Efsa\Client\Gitea\Configuration;
use Efsa\Client\Gitea\HeaderSelector;
use Efsa\Client\Gitea\ObjectSerializer;

/**
 * IssueApi Class Doc Comment
 *
 * @category Class
 * @package  Efsa\Client\Gitea
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class IssueApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation issueAddLabel
     *
     * Add a label to an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \Efsa\Client\Gitea\Model\IssueLabelsOption $body body (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\Label[]
     */
    public function issueAddLabel($owner, $repo, $index, $body = null)
    {
        list($response) = $this->issueAddLabelWithHttpInfo($owner, $repo, $index, $body);
        return $response;
    }

    /**
     * Operation issueAddLabelWithHttpInfo
     *
     * Add a label to an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \Efsa\Client\Gitea\Model\IssueLabelsOption $body (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\Label[], HTTP status code, HTTP response headers (array of strings)
     */
    public function issueAddLabelWithHttpInfo($owner, $repo, $index, $body = null)
    {
        $request = $this->issueAddLabelRequest($owner, $repo, $index, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Efsa\Client\Gitea\Model\Label[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\Label[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\Label[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\Label[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueAddLabelAsync
     *
     * Add a label to an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \Efsa\Client\Gitea\Model\IssueLabelsOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueAddLabelAsync($owner, $repo, $index, $body = null)
    {
        return $this->issueAddLabelAsyncWithHttpInfo($owner, $repo, $index, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueAddLabelAsyncWithHttpInfo
     *
     * Add a label to an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \Efsa\Client\Gitea\Model\IssueLabelsOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueAddLabelAsyncWithHttpInfo($owner, $repo, $index, $body = null)
    {
        $returnType = '\Efsa\Client\Gitea\Model\Label[]';
        $request = $this->issueAddLabelRequest($owner, $repo, $index, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueAddLabel'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \Efsa\Client\Gitea\Model\IssueLabelsOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueAddLabelRequest($owner, $repo, $index, $body = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueAddLabel'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueAddLabel'
            );
        }
        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling issueAddLabel'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/{index}/labels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($body)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueAddSubscription
     *
     * Subscribe user to issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  string $user user to subscribe (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function issueAddSubscription($owner, $repo, $index, $user)
    {
        $this->issueAddSubscriptionWithHttpInfo($owner, $repo, $index, $user);
    }

    /**
     * Operation issueAddSubscriptionWithHttpInfo
     *
     * Subscribe user to issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  string $user user to subscribe (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueAddSubscriptionWithHttpInfo($owner, $repo, $index, $user)
    {
        $request = $this->issueAddSubscriptionRequest($owner, $repo, $index, $user);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation issueAddSubscriptionAsync
     *
     * Subscribe user to issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  string $user user to subscribe (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueAddSubscriptionAsync($owner, $repo, $index, $user)
    {
        return $this->issueAddSubscriptionAsyncWithHttpInfo($owner, $repo, $index, $user)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueAddSubscriptionAsyncWithHttpInfo
     *
     * Subscribe user to issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  string $user user to subscribe (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueAddSubscriptionAsyncWithHttpInfo($owner, $repo, $index, $user)
    {
        $returnType = '';
        $request = $this->issueAddSubscriptionRequest($owner, $repo, $index, $user);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueAddSubscription'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  string $user user to subscribe (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueAddSubscriptionRequest($owner, $repo, $index, $user)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueAddSubscription'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueAddSubscription'
            );
        }
        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling issueAddSubscription'
            );
        }
        // verify the required parameter 'user' is set
        if ($user === null || (is_array($user) && count($user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user when calling issueAddSubscription'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/{index}/subscriptions/{user}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }
        // path params
        if ($user !== null) {
            $resourcePath = str_replace(
                '{' . 'user' . '}',
                ObjectSerializer::toPathValue($user),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueAddTime
     *
     * Add tracked time to a issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \Efsa\Client\Gitea\Model\AddTimeOption $body body (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\TrackedTime
     */
    public function issueAddTime($owner, $repo, $index, $body = null)
    {
        list($response) = $this->issueAddTimeWithHttpInfo($owner, $repo, $index, $body);
        return $response;
    }

    /**
     * Operation issueAddTimeWithHttpInfo
     *
     * Add tracked time to a issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \Efsa\Client\Gitea\Model\AddTimeOption $body (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\TrackedTime, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueAddTimeWithHttpInfo($owner, $repo, $index, $body = null)
    {
        $request = $this->issueAddTimeRequest($owner, $repo, $index, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Efsa\Client\Gitea\Model\TrackedTime' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\TrackedTime', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\TrackedTime';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\TrackedTime',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueAddTimeAsync
     *
     * Add tracked time to a issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \Efsa\Client\Gitea\Model\AddTimeOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueAddTimeAsync($owner, $repo, $index, $body = null)
    {
        return $this->issueAddTimeAsyncWithHttpInfo($owner, $repo, $index, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueAddTimeAsyncWithHttpInfo
     *
     * Add tracked time to a issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \Efsa\Client\Gitea\Model\AddTimeOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueAddTimeAsyncWithHttpInfo($owner, $repo, $index, $body = null)
    {
        $returnType = '\Efsa\Client\Gitea\Model\TrackedTime';
        $request = $this->issueAddTimeRequest($owner, $repo, $index, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueAddTime'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \Efsa\Client\Gitea\Model\AddTimeOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueAddTimeRequest($owner, $repo, $index, $body = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueAddTime'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueAddTime'
            );
        }
        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling issueAddTime'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/{index}/times';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($body)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueCheckSubscription
     *
     * Check if user is subscribed to an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\WatchInfo
     */
    public function issueCheckSubscription($owner, $repo, $index)
    {
        list($response) = $this->issueCheckSubscriptionWithHttpInfo($owner, $repo, $index);
        return $response;
    }

    /**
     * Operation issueCheckSubscriptionWithHttpInfo
     *
     * Check if user is subscribed to an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\WatchInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueCheckSubscriptionWithHttpInfo($owner, $repo, $index)
    {
        $request = $this->issueCheckSubscriptionRequest($owner, $repo, $index);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Efsa\Client\Gitea\Model\WatchInfo' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\WatchInfo', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\WatchInfo';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\WatchInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueCheckSubscriptionAsync
     *
     * Check if user is subscribed to an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueCheckSubscriptionAsync($owner, $repo, $index)
    {
        return $this->issueCheckSubscriptionAsyncWithHttpInfo($owner, $repo, $index)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueCheckSubscriptionAsyncWithHttpInfo
     *
     * Check if user is subscribed to an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueCheckSubscriptionAsyncWithHttpInfo($owner, $repo, $index)
    {
        $returnType = '\Efsa\Client\Gitea\Model\WatchInfo';
        $request = $this->issueCheckSubscriptionRequest($owner, $repo, $index);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueCheckSubscription'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueCheckSubscriptionRequest($owner, $repo, $index)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueCheckSubscription'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueCheckSubscription'
            );
        }
        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling issueCheckSubscription'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/{index}/subscriptions/check';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueClearLabels
     *
     * Remove all labels from an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function issueClearLabels($owner, $repo, $index)
    {
        $this->issueClearLabelsWithHttpInfo($owner, $repo, $index);
    }

    /**
     * Operation issueClearLabelsWithHttpInfo
     *
     * Remove all labels from an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueClearLabelsWithHttpInfo($owner, $repo, $index)
    {
        $request = $this->issueClearLabelsRequest($owner, $repo, $index);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation issueClearLabelsAsync
     *
     * Remove all labels from an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueClearLabelsAsync($owner, $repo, $index)
    {
        return $this->issueClearLabelsAsyncWithHttpInfo($owner, $repo, $index)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueClearLabelsAsyncWithHttpInfo
     *
     * Remove all labels from an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueClearLabelsAsyncWithHttpInfo($owner, $repo, $index)
    {
        $returnType = '';
        $request = $this->issueClearLabelsRequest($owner, $repo, $index);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueClearLabels'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueClearLabelsRequest($owner, $repo, $index)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueClearLabels'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueClearLabels'
            );
        }
        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling issueClearLabels'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/{index}/labels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueCreateComment
     *
     * Add a comment to an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \Efsa\Client\Gitea\Model\CreateIssueCommentOption $body body (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\Comment
     */
    public function issueCreateComment($owner, $repo, $index, $body = null)
    {
        list($response) = $this->issueCreateCommentWithHttpInfo($owner, $repo, $index, $body);
        return $response;
    }

    /**
     * Operation issueCreateCommentWithHttpInfo
     *
     * Add a comment to an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \Efsa\Client\Gitea\Model\CreateIssueCommentOption $body (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\Comment, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueCreateCommentWithHttpInfo($owner, $repo, $index, $body = null)
    {
        $request = $this->issueCreateCommentRequest($owner, $repo, $index, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\Efsa\Client\Gitea\Model\Comment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\Comment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\Comment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\Comment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueCreateCommentAsync
     *
     * Add a comment to an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \Efsa\Client\Gitea\Model\CreateIssueCommentOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueCreateCommentAsync($owner, $repo, $index, $body = null)
    {
        return $this->issueCreateCommentAsyncWithHttpInfo($owner, $repo, $index, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueCreateCommentAsyncWithHttpInfo
     *
     * Add a comment to an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \Efsa\Client\Gitea\Model\CreateIssueCommentOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueCreateCommentAsyncWithHttpInfo($owner, $repo, $index, $body = null)
    {
        $returnType = '\Efsa\Client\Gitea\Model\Comment';
        $request = $this->issueCreateCommentRequest($owner, $repo, $index, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueCreateComment'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \Efsa\Client\Gitea\Model\CreateIssueCommentOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueCreateCommentRequest($owner, $repo, $index, $body = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueCreateComment'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueCreateComment'
            );
        }
        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling issueCreateComment'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/{index}/comments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($body)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueCreateIssue
     *
     * Create an issue. If using deadline only the date will be taken into account, and time of day ignored.
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  \Efsa\Client\Gitea\Model\CreateIssueOption $body body (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\Issue
     */
    public function issueCreateIssue($owner, $repo, $body = null)
    {
        list($response) = $this->issueCreateIssueWithHttpInfo($owner, $repo, $body);
        return $response;
    }

    /**
     * Operation issueCreateIssueWithHttpInfo
     *
     * Create an issue. If using deadline only the date will be taken into account, and time of day ignored.
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  \Efsa\Client\Gitea\Model\CreateIssueOption $body (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\Issue, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueCreateIssueWithHttpInfo($owner, $repo, $body = null)
    {
        $request = $this->issueCreateIssueRequest($owner, $repo, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\Efsa\Client\Gitea\Model\Issue' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\Issue', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\Issue';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\Issue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueCreateIssueAsync
     *
     * Create an issue. If using deadline only the date will be taken into account, and time of day ignored.
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  \Efsa\Client\Gitea\Model\CreateIssueOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueCreateIssueAsync($owner, $repo, $body = null)
    {
        return $this->issueCreateIssueAsyncWithHttpInfo($owner, $repo, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueCreateIssueAsyncWithHttpInfo
     *
     * Create an issue. If using deadline only the date will be taken into account, and time of day ignored.
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  \Efsa\Client\Gitea\Model\CreateIssueOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueCreateIssueAsyncWithHttpInfo($owner, $repo, $body = null)
    {
        $returnType = '\Efsa\Client\Gitea\Model\Issue';
        $request = $this->issueCreateIssueRequest($owner, $repo, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueCreateIssue'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  \Efsa\Client\Gitea\Model\CreateIssueOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueCreateIssueRequest($owner, $repo, $body = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueCreateIssue'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueCreateIssue'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($body)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueCreateLabel
     *
     * Create a label
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  \Efsa\Client\Gitea\Model\CreateLabelOption $body body (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\Label
     */
    public function issueCreateLabel($owner, $repo, $body = null)
    {
        list($response) = $this->issueCreateLabelWithHttpInfo($owner, $repo, $body);
        return $response;
    }

    /**
     * Operation issueCreateLabelWithHttpInfo
     *
     * Create a label
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  \Efsa\Client\Gitea\Model\CreateLabelOption $body (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\Label, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueCreateLabelWithHttpInfo($owner, $repo, $body = null)
    {
        $request = $this->issueCreateLabelRequest($owner, $repo, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\Efsa\Client\Gitea\Model\Label' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\Label', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\Label';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\Label',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueCreateLabelAsync
     *
     * Create a label
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  \Efsa\Client\Gitea\Model\CreateLabelOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueCreateLabelAsync($owner, $repo, $body = null)
    {
        return $this->issueCreateLabelAsyncWithHttpInfo($owner, $repo, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueCreateLabelAsyncWithHttpInfo
     *
     * Create a label
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  \Efsa\Client\Gitea\Model\CreateLabelOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueCreateLabelAsyncWithHttpInfo($owner, $repo, $body = null)
    {
        $returnType = '\Efsa\Client\Gitea\Model\Label';
        $request = $this->issueCreateLabelRequest($owner, $repo, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueCreateLabel'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  \Efsa\Client\Gitea\Model\CreateLabelOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueCreateLabelRequest($owner, $repo, $body = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueCreateLabel'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueCreateLabel'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/labels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($body)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueCreateMilestone
     *
     * Create a milestone
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  \Efsa\Client\Gitea\Model\CreateMilestoneOption $body body (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\Milestone
     */
    public function issueCreateMilestone($owner, $repo, $body = null)
    {
        list($response) = $this->issueCreateMilestoneWithHttpInfo($owner, $repo, $body);
        return $response;
    }

    /**
     * Operation issueCreateMilestoneWithHttpInfo
     *
     * Create a milestone
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  \Efsa\Client\Gitea\Model\CreateMilestoneOption $body (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\Milestone, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueCreateMilestoneWithHttpInfo($owner, $repo, $body = null)
    {
        $request = $this->issueCreateMilestoneRequest($owner, $repo, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\Efsa\Client\Gitea\Model\Milestone' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\Milestone', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\Milestone';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\Milestone',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueCreateMilestoneAsync
     *
     * Create a milestone
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  \Efsa\Client\Gitea\Model\CreateMilestoneOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueCreateMilestoneAsync($owner, $repo, $body = null)
    {
        return $this->issueCreateMilestoneAsyncWithHttpInfo($owner, $repo, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueCreateMilestoneAsyncWithHttpInfo
     *
     * Create a milestone
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  \Efsa\Client\Gitea\Model\CreateMilestoneOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueCreateMilestoneAsyncWithHttpInfo($owner, $repo, $body = null)
    {
        $returnType = '\Efsa\Client\Gitea\Model\Milestone';
        $request = $this->issueCreateMilestoneRequest($owner, $repo, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueCreateMilestone'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  \Efsa\Client\Gitea\Model\CreateMilestoneOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueCreateMilestoneRequest($owner, $repo, $body = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueCreateMilestone'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueCreateMilestone'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/milestones';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($body)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueDelete
     *
     * Delete an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of issue to delete (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function issueDelete($owner, $repo, $index)
    {
        $this->issueDeleteWithHttpInfo($owner, $repo, $index);
    }

    /**
     * Operation issueDeleteWithHttpInfo
     *
     * Delete an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of issue to delete (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueDeleteWithHttpInfo($owner, $repo, $index)
    {
        $request = $this->issueDeleteRequest($owner, $repo, $index);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation issueDeleteAsync
     *
     * Delete an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of issue to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueDeleteAsync($owner, $repo, $index)
    {
        return $this->issueDeleteAsyncWithHttpInfo($owner, $repo, $index)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueDeleteAsyncWithHttpInfo
     *
     * Delete an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of issue to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueDeleteAsyncWithHttpInfo($owner, $repo, $index)
    {
        $returnType = '';
        $request = $this->issueDeleteRequest($owner, $repo, $index);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueDelete'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of issue to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueDeleteRequest($owner, $repo, $index)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueDelete'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueDelete'
            );
        }
        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling issueDelete'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/{index}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueDeleteComment
     *
     * Delete a comment
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of comment to delete (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function issueDeleteComment($owner, $repo, $id)
    {
        $this->issueDeleteCommentWithHttpInfo($owner, $repo, $id);
    }

    /**
     * Operation issueDeleteCommentWithHttpInfo
     *
     * Delete a comment
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of comment to delete (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueDeleteCommentWithHttpInfo($owner, $repo, $id)
    {
        $request = $this->issueDeleteCommentRequest($owner, $repo, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation issueDeleteCommentAsync
     *
     * Delete a comment
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of comment to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueDeleteCommentAsync($owner, $repo, $id)
    {
        return $this->issueDeleteCommentAsyncWithHttpInfo($owner, $repo, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueDeleteCommentAsyncWithHttpInfo
     *
     * Delete a comment
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of comment to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueDeleteCommentAsyncWithHttpInfo($owner, $repo, $id)
    {
        $returnType = '';
        $request = $this->issueDeleteCommentRequest($owner, $repo, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueDeleteComment'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of comment to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueDeleteCommentRequest($owner, $repo, $id)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueDeleteComment'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueDeleteComment'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling issueDeleteComment'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/comments/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueDeleteCommentDeprecated
     *
     * Delete a comment
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index this parameter is ignored (required)
     * @param  int $id id of comment to delete (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function issueDeleteCommentDeprecated($owner, $repo, $index, $id)
    {
        $this->issueDeleteCommentDeprecatedWithHttpInfo($owner, $repo, $index, $id);
    }

    /**
     * Operation issueDeleteCommentDeprecatedWithHttpInfo
     *
     * Delete a comment
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index this parameter is ignored (required)
     * @param  int $id id of comment to delete (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueDeleteCommentDeprecatedWithHttpInfo($owner, $repo, $index, $id)
    {
        $request = $this->issueDeleteCommentDeprecatedRequest($owner, $repo, $index, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation issueDeleteCommentDeprecatedAsync
     *
     * Delete a comment
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index this parameter is ignored (required)
     * @param  int $id id of comment to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueDeleteCommentDeprecatedAsync($owner, $repo, $index, $id)
    {
        return $this->issueDeleteCommentDeprecatedAsyncWithHttpInfo($owner, $repo, $index, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueDeleteCommentDeprecatedAsyncWithHttpInfo
     *
     * Delete a comment
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index this parameter is ignored (required)
     * @param  int $id id of comment to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueDeleteCommentDeprecatedAsyncWithHttpInfo($owner, $repo, $index, $id)
    {
        $returnType = '';
        $request = $this->issueDeleteCommentDeprecatedRequest($owner, $repo, $index, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueDeleteCommentDeprecated'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index this parameter is ignored (required)
     * @param  int $id id of comment to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueDeleteCommentDeprecatedRequest($owner, $repo, $index, $id)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueDeleteCommentDeprecated'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueDeleteCommentDeprecated'
            );
        }
        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling issueDeleteCommentDeprecated'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling issueDeleteCommentDeprecated'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/{index}/comments/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueDeleteCommentReaction
     *
     * Remove a reaction from a comment of an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the comment to edit (required)
     * @param  \Efsa\Client\Gitea\Model\EditReactionOption $content content (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function issueDeleteCommentReaction($owner, $repo, $id, $content = null)
    {
        $this->issueDeleteCommentReactionWithHttpInfo($owner, $repo, $id, $content);
    }

    /**
     * Operation issueDeleteCommentReactionWithHttpInfo
     *
     * Remove a reaction from a comment of an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the comment to edit (required)
     * @param  \Efsa\Client\Gitea\Model\EditReactionOption $content (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueDeleteCommentReactionWithHttpInfo($owner, $repo, $id, $content = null)
    {
        $request = $this->issueDeleteCommentReactionRequest($owner, $repo, $id, $content);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation issueDeleteCommentReactionAsync
     *
     * Remove a reaction from a comment of an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the comment to edit (required)
     * @param  \Efsa\Client\Gitea\Model\EditReactionOption $content (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueDeleteCommentReactionAsync($owner, $repo, $id, $content = null)
    {
        return $this->issueDeleteCommentReactionAsyncWithHttpInfo($owner, $repo, $id, $content)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueDeleteCommentReactionAsyncWithHttpInfo
     *
     * Remove a reaction from a comment of an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the comment to edit (required)
     * @param  \Efsa\Client\Gitea\Model\EditReactionOption $content (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueDeleteCommentReactionAsyncWithHttpInfo($owner, $repo, $id, $content = null)
    {
        $returnType = '';
        $request = $this->issueDeleteCommentReactionRequest($owner, $repo, $id, $content);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueDeleteCommentReaction'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the comment to edit (required)
     * @param  \Efsa\Client\Gitea\Model\EditReactionOption $content (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueDeleteCommentReactionRequest($owner, $repo, $id, $content = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueDeleteCommentReaction'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueDeleteCommentReaction'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling issueDeleteCommentReaction'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/comments/{id}/reactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($content)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($content));
            } else {
                $httpBody = $content;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueDeleteIssueReaction
     *
     * Remove a reaction from an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \Efsa\Client\Gitea\Model\EditReactionOption $content content (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function issueDeleteIssueReaction($owner, $repo, $index, $content = null)
    {
        $this->issueDeleteIssueReactionWithHttpInfo($owner, $repo, $index, $content);
    }

    /**
     * Operation issueDeleteIssueReactionWithHttpInfo
     *
     * Remove a reaction from an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \Efsa\Client\Gitea\Model\EditReactionOption $content (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueDeleteIssueReactionWithHttpInfo($owner, $repo, $index, $content = null)
    {
        $request = $this->issueDeleteIssueReactionRequest($owner, $repo, $index, $content);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation issueDeleteIssueReactionAsync
     *
     * Remove a reaction from an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \Efsa\Client\Gitea\Model\EditReactionOption $content (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueDeleteIssueReactionAsync($owner, $repo, $index, $content = null)
    {
        return $this->issueDeleteIssueReactionAsyncWithHttpInfo($owner, $repo, $index, $content)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueDeleteIssueReactionAsyncWithHttpInfo
     *
     * Remove a reaction from an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \Efsa\Client\Gitea\Model\EditReactionOption $content (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueDeleteIssueReactionAsyncWithHttpInfo($owner, $repo, $index, $content = null)
    {
        $returnType = '';
        $request = $this->issueDeleteIssueReactionRequest($owner, $repo, $index, $content);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueDeleteIssueReaction'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \Efsa\Client\Gitea\Model\EditReactionOption $content (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueDeleteIssueReactionRequest($owner, $repo, $index, $content = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueDeleteIssueReaction'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueDeleteIssueReaction'
            );
        }
        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling issueDeleteIssueReaction'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/{index}/reactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($content)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($content));
            } else {
                $httpBody = $content;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueDeleteLabel
     *
     * Delete a label
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the label to delete (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function issueDeleteLabel($owner, $repo, $id)
    {
        $this->issueDeleteLabelWithHttpInfo($owner, $repo, $id);
    }

    /**
     * Operation issueDeleteLabelWithHttpInfo
     *
     * Delete a label
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the label to delete (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueDeleteLabelWithHttpInfo($owner, $repo, $id)
    {
        $request = $this->issueDeleteLabelRequest($owner, $repo, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation issueDeleteLabelAsync
     *
     * Delete a label
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the label to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueDeleteLabelAsync($owner, $repo, $id)
    {
        return $this->issueDeleteLabelAsyncWithHttpInfo($owner, $repo, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueDeleteLabelAsyncWithHttpInfo
     *
     * Delete a label
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the label to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueDeleteLabelAsyncWithHttpInfo($owner, $repo, $id)
    {
        $returnType = '';
        $request = $this->issueDeleteLabelRequest($owner, $repo, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueDeleteLabel'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the label to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueDeleteLabelRequest($owner, $repo, $id)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueDeleteLabel'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueDeleteLabel'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling issueDeleteLabel'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/labels/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueDeleteMilestone
     *
     * Delete a milestone
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  string $id the milestone to delete, identified by ID and if not available by name (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function issueDeleteMilestone($owner, $repo, $id)
    {
        $this->issueDeleteMilestoneWithHttpInfo($owner, $repo, $id);
    }

    /**
     * Operation issueDeleteMilestoneWithHttpInfo
     *
     * Delete a milestone
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  string $id the milestone to delete, identified by ID and if not available by name (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueDeleteMilestoneWithHttpInfo($owner, $repo, $id)
    {
        $request = $this->issueDeleteMilestoneRequest($owner, $repo, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation issueDeleteMilestoneAsync
     *
     * Delete a milestone
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  string $id the milestone to delete, identified by ID and if not available by name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueDeleteMilestoneAsync($owner, $repo, $id)
    {
        return $this->issueDeleteMilestoneAsyncWithHttpInfo($owner, $repo, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueDeleteMilestoneAsyncWithHttpInfo
     *
     * Delete a milestone
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  string $id the milestone to delete, identified by ID and if not available by name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueDeleteMilestoneAsyncWithHttpInfo($owner, $repo, $id)
    {
        $returnType = '';
        $request = $this->issueDeleteMilestoneRequest($owner, $repo, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueDeleteMilestone'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  string $id the milestone to delete, identified by ID and if not available by name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueDeleteMilestoneRequest($owner, $repo, $id)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueDeleteMilestone'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueDeleteMilestone'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling issueDeleteMilestone'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/milestones/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueDeleteStopWatch
     *
     * Delete an issue&#39;s existing stopwatch.
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to stop the stopwatch on (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function issueDeleteStopWatch($owner, $repo, $index)
    {
        $this->issueDeleteStopWatchWithHttpInfo($owner, $repo, $index);
    }

    /**
     * Operation issueDeleteStopWatchWithHttpInfo
     *
     * Delete an issue&#39;s existing stopwatch.
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to stop the stopwatch on (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueDeleteStopWatchWithHttpInfo($owner, $repo, $index)
    {
        $request = $this->issueDeleteStopWatchRequest($owner, $repo, $index);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation issueDeleteStopWatchAsync
     *
     * Delete an issue&#39;s existing stopwatch.
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to stop the stopwatch on (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueDeleteStopWatchAsync($owner, $repo, $index)
    {
        return $this->issueDeleteStopWatchAsyncWithHttpInfo($owner, $repo, $index)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueDeleteStopWatchAsyncWithHttpInfo
     *
     * Delete an issue&#39;s existing stopwatch.
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to stop the stopwatch on (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueDeleteStopWatchAsyncWithHttpInfo($owner, $repo, $index)
    {
        $returnType = '';
        $request = $this->issueDeleteStopWatchRequest($owner, $repo, $index);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueDeleteStopWatch'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to stop the stopwatch on (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueDeleteStopWatchRequest($owner, $repo, $index)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueDeleteStopWatch'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueDeleteStopWatch'
            );
        }
        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling issueDeleteStopWatch'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/{index}/stopwatch/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueDeleteSubscription
     *
     * Unsubscribe user from issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  string $user user witch unsubscribe (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function issueDeleteSubscription($owner, $repo, $index, $user)
    {
        $this->issueDeleteSubscriptionWithHttpInfo($owner, $repo, $index, $user);
    }

    /**
     * Operation issueDeleteSubscriptionWithHttpInfo
     *
     * Unsubscribe user from issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  string $user user witch unsubscribe (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueDeleteSubscriptionWithHttpInfo($owner, $repo, $index, $user)
    {
        $request = $this->issueDeleteSubscriptionRequest($owner, $repo, $index, $user);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation issueDeleteSubscriptionAsync
     *
     * Unsubscribe user from issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  string $user user witch unsubscribe (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueDeleteSubscriptionAsync($owner, $repo, $index, $user)
    {
        return $this->issueDeleteSubscriptionAsyncWithHttpInfo($owner, $repo, $index, $user)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueDeleteSubscriptionAsyncWithHttpInfo
     *
     * Unsubscribe user from issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  string $user user witch unsubscribe (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueDeleteSubscriptionAsyncWithHttpInfo($owner, $repo, $index, $user)
    {
        $returnType = '';
        $request = $this->issueDeleteSubscriptionRequest($owner, $repo, $index, $user);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueDeleteSubscription'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  string $user user witch unsubscribe (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueDeleteSubscriptionRequest($owner, $repo, $index, $user)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueDeleteSubscription'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueDeleteSubscription'
            );
        }
        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling issueDeleteSubscription'
            );
        }
        // verify the required parameter 'user' is set
        if ($user === null || (is_array($user) && count($user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user when calling issueDeleteSubscription'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/{index}/subscriptions/{user}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }
        // path params
        if ($user !== null) {
            $resourcePath = str_replace(
                '{' . 'user' . '}',
                ObjectSerializer::toPathValue($user),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueDeleteTime
     *
     * Delete specific tracked time
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  int $id id of time to delete (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function issueDeleteTime($owner, $repo, $index, $id)
    {
        $this->issueDeleteTimeWithHttpInfo($owner, $repo, $index, $id);
    }

    /**
     * Operation issueDeleteTimeWithHttpInfo
     *
     * Delete specific tracked time
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  int $id id of time to delete (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueDeleteTimeWithHttpInfo($owner, $repo, $index, $id)
    {
        $request = $this->issueDeleteTimeRequest($owner, $repo, $index, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation issueDeleteTimeAsync
     *
     * Delete specific tracked time
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  int $id id of time to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueDeleteTimeAsync($owner, $repo, $index, $id)
    {
        return $this->issueDeleteTimeAsyncWithHttpInfo($owner, $repo, $index, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueDeleteTimeAsyncWithHttpInfo
     *
     * Delete specific tracked time
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  int $id id of time to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueDeleteTimeAsyncWithHttpInfo($owner, $repo, $index, $id)
    {
        $returnType = '';
        $request = $this->issueDeleteTimeRequest($owner, $repo, $index, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueDeleteTime'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  int $id id of time to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueDeleteTimeRequest($owner, $repo, $index, $id)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueDeleteTime'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueDeleteTime'
            );
        }
        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling issueDeleteTime'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling issueDeleteTime'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/{index}/times/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueEditComment
     *
     * Edit a comment
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the comment to edit (required)
     * @param  \Efsa\Client\Gitea\Model\EditIssueCommentOption $body body (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\Comment
     */
    public function issueEditComment($owner, $repo, $id, $body = null)
    {
        list($response) = $this->issueEditCommentWithHttpInfo($owner, $repo, $id, $body);
        return $response;
    }

    /**
     * Operation issueEditCommentWithHttpInfo
     *
     * Edit a comment
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the comment to edit (required)
     * @param  \Efsa\Client\Gitea\Model\EditIssueCommentOption $body (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\Comment, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueEditCommentWithHttpInfo($owner, $repo, $id, $body = null)
    {
        $request = $this->issueEditCommentRequest($owner, $repo, $id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Efsa\Client\Gitea\Model\Comment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\Comment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\Comment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\Comment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueEditCommentAsync
     *
     * Edit a comment
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the comment to edit (required)
     * @param  \Efsa\Client\Gitea\Model\EditIssueCommentOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueEditCommentAsync($owner, $repo, $id, $body = null)
    {
        return $this->issueEditCommentAsyncWithHttpInfo($owner, $repo, $id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueEditCommentAsyncWithHttpInfo
     *
     * Edit a comment
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the comment to edit (required)
     * @param  \Efsa\Client\Gitea\Model\EditIssueCommentOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueEditCommentAsyncWithHttpInfo($owner, $repo, $id, $body = null)
    {
        $returnType = '\Efsa\Client\Gitea\Model\Comment';
        $request = $this->issueEditCommentRequest($owner, $repo, $id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueEditComment'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the comment to edit (required)
     * @param  \Efsa\Client\Gitea\Model\EditIssueCommentOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueEditCommentRequest($owner, $repo, $id, $body = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueEditComment'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueEditComment'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling issueEditComment'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/comments/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($body)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueEditCommentDeprecated
     *
     * Edit a comment
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index this parameter is ignored (required)
     * @param  int $id id of the comment to edit (required)
     * @param  \Efsa\Client\Gitea\Model\EditIssueCommentOption $body body (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\Comment
     */
    public function issueEditCommentDeprecated($owner, $repo, $index, $id, $body = null)
    {
        list($response) = $this->issueEditCommentDeprecatedWithHttpInfo($owner, $repo, $index, $id, $body);
        return $response;
    }

    /**
     * Operation issueEditCommentDeprecatedWithHttpInfo
     *
     * Edit a comment
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index this parameter is ignored (required)
     * @param  int $id id of the comment to edit (required)
     * @param  \Efsa\Client\Gitea\Model\EditIssueCommentOption $body (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\Comment, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueEditCommentDeprecatedWithHttpInfo($owner, $repo, $index, $id, $body = null)
    {
        $request = $this->issueEditCommentDeprecatedRequest($owner, $repo, $index, $id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Efsa\Client\Gitea\Model\Comment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\Comment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\Comment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\Comment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueEditCommentDeprecatedAsync
     *
     * Edit a comment
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index this parameter is ignored (required)
     * @param  int $id id of the comment to edit (required)
     * @param  \Efsa\Client\Gitea\Model\EditIssueCommentOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueEditCommentDeprecatedAsync($owner, $repo, $index, $id, $body = null)
    {
        return $this->issueEditCommentDeprecatedAsyncWithHttpInfo($owner, $repo, $index, $id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueEditCommentDeprecatedAsyncWithHttpInfo
     *
     * Edit a comment
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index this parameter is ignored (required)
     * @param  int $id id of the comment to edit (required)
     * @param  \Efsa\Client\Gitea\Model\EditIssueCommentOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueEditCommentDeprecatedAsyncWithHttpInfo($owner, $repo, $index, $id, $body = null)
    {
        $returnType = '\Efsa\Client\Gitea\Model\Comment';
        $request = $this->issueEditCommentDeprecatedRequest($owner, $repo, $index, $id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueEditCommentDeprecated'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index this parameter is ignored (required)
     * @param  int $id id of the comment to edit (required)
     * @param  \Efsa\Client\Gitea\Model\EditIssueCommentOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueEditCommentDeprecatedRequest($owner, $repo, $index, $id, $body = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueEditCommentDeprecated'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueEditCommentDeprecated'
            );
        }
        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling issueEditCommentDeprecated'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling issueEditCommentDeprecated'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/{index}/comments/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($body)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueEditIssue
     *
     * Edit an issue. If using deadline only the date will be taken into account, and time of day ignored.
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to edit (required)
     * @param  \Efsa\Client\Gitea\Model\EditIssueOption $body body (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\Issue
     */
    public function issueEditIssue($owner, $repo, $index, $body = null)
    {
        list($response) = $this->issueEditIssueWithHttpInfo($owner, $repo, $index, $body);
        return $response;
    }

    /**
     * Operation issueEditIssueWithHttpInfo
     *
     * Edit an issue. If using deadline only the date will be taken into account, and time of day ignored.
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to edit (required)
     * @param  \Efsa\Client\Gitea\Model\EditIssueOption $body (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\Issue, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueEditIssueWithHttpInfo($owner, $repo, $index, $body = null)
    {
        $request = $this->issueEditIssueRequest($owner, $repo, $index, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\Efsa\Client\Gitea\Model\Issue' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\Issue', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\Issue';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\Issue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueEditIssueAsync
     *
     * Edit an issue. If using deadline only the date will be taken into account, and time of day ignored.
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to edit (required)
     * @param  \Efsa\Client\Gitea\Model\EditIssueOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueEditIssueAsync($owner, $repo, $index, $body = null)
    {
        return $this->issueEditIssueAsyncWithHttpInfo($owner, $repo, $index, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueEditIssueAsyncWithHttpInfo
     *
     * Edit an issue. If using deadline only the date will be taken into account, and time of day ignored.
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to edit (required)
     * @param  \Efsa\Client\Gitea\Model\EditIssueOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueEditIssueAsyncWithHttpInfo($owner, $repo, $index, $body = null)
    {
        $returnType = '\Efsa\Client\Gitea\Model\Issue';
        $request = $this->issueEditIssueRequest($owner, $repo, $index, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueEditIssue'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to edit (required)
     * @param  \Efsa\Client\Gitea\Model\EditIssueOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueEditIssueRequest($owner, $repo, $index, $body = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueEditIssue'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueEditIssue'
            );
        }
        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling issueEditIssue'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/{index}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($body)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueEditIssueDeadline
     *
     * Set an issue deadline. If set to null, the deadline is deleted. If using deadline only the date will be taken into account, and time of day ignored.
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to create or update a deadline on (required)
     * @param  \Efsa\Client\Gitea\Model\EditDeadlineOption $body body (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\IssueDeadline
     */
    public function issueEditIssueDeadline($owner, $repo, $index, $body = null)
    {
        list($response) = $this->issueEditIssueDeadlineWithHttpInfo($owner, $repo, $index, $body);
        return $response;
    }

    /**
     * Operation issueEditIssueDeadlineWithHttpInfo
     *
     * Set an issue deadline. If set to null, the deadline is deleted. If using deadline only the date will be taken into account, and time of day ignored.
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to create or update a deadline on (required)
     * @param  \Efsa\Client\Gitea\Model\EditDeadlineOption $body (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\IssueDeadline, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueEditIssueDeadlineWithHttpInfo($owner, $repo, $index, $body = null)
    {
        $request = $this->issueEditIssueDeadlineRequest($owner, $repo, $index, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\Efsa\Client\Gitea\Model\IssueDeadline' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\IssueDeadline', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\IssueDeadline';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\IssueDeadline',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueEditIssueDeadlineAsync
     *
     * Set an issue deadline. If set to null, the deadline is deleted. If using deadline only the date will be taken into account, and time of day ignored.
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to create or update a deadline on (required)
     * @param  \Efsa\Client\Gitea\Model\EditDeadlineOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueEditIssueDeadlineAsync($owner, $repo, $index, $body = null)
    {
        return $this->issueEditIssueDeadlineAsyncWithHttpInfo($owner, $repo, $index, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueEditIssueDeadlineAsyncWithHttpInfo
     *
     * Set an issue deadline. If set to null, the deadline is deleted. If using deadline only the date will be taken into account, and time of day ignored.
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to create or update a deadline on (required)
     * @param  \Efsa\Client\Gitea\Model\EditDeadlineOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueEditIssueDeadlineAsyncWithHttpInfo($owner, $repo, $index, $body = null)
    {
        $returnType = '\Efsa\Client\Gitea\Model\IssueDeadline';
        $request = $this->issueEditIssueDeadlineRequest($owner, $repo, $index, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueEditIssueDeadline'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to create or update a deadline on (required)
     * @param  \Efsa\Client\Gitea\Model\EditDeadlineOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueEditIssueDeadlineRequest($owner, $repo, $index, $body = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueEditIssueDeadline'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueEditIssueDeadline'
            );
        }
        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling issueEditIssueDeadline'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/{index}/deadline';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($body)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueEditLabel
     *
     * Update a label
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the label to edit (required)
     * @param  \Efsa\Client\Gitea\Model\EditLabelOption $body body (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\Label
     */
    public function issueEditLabel($owner, $repo, $id, $body = null)
    {
        list($response) = $this->issueEditLabelWithHttpInfo($owner, $repo, $id, $body);
        return $response;
    }

    /**
     * Operation issueEditLabelWithHttpInfo
     *
     * Update a label
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the label to edit (required)
     * @param  \Efsa\Client\Gitea\Model\EditLabelOption $body (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\Label, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueEditLabelWithHttpInfo($owner, $repo, $id, $body = null)
    {
        $request = $this->issueEditLabelRequest($owner, $repo, $id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Efsa\Client\Gitea\Model\Label' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\Label', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\Label';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\Label',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueEditLabelAsync
     *
     * Update a label
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the label to edit (required)
     * @param  \Efsa\Client\Gitea\Model\EditLabelOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueEditLabelAsync($owner, $repo, $id, $body = null)
    {
        return $this->issueEditLabelAsyncWithHttpInfo($owner, $repo, $id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueEditLabelAsyncWithHttpInfo
     *
     * Update a label
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the label to edit (required)
     * @param  \Efsa\Client\Gitea\Model\EditLabelOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueEditLabelAsyncWithHttpInfo($owner, $repo, $id, $body = null)
    {
        $returnType = '\Efsa\Client\Gitea\Model\Label';
        $request = $this->issueEditLabelRequest($owner, $repo, $id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueEditLabel'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the label to edit (required)
     * @param  \Efsa\Client\Gitea\Model\EditLabelOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueEditLabelRequest($owner, $repo, $id, $body = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueEditLabel'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueEditLabel'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling issueEditLabel'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/labels/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($body)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueEditMilestone
     *
     * Update a milestone
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  string $id the milestone to edit, identified by ID and if not available by name (required)
     * @param  \Efsa\Client\Gitea\Model\EditMilestoneOption $body body (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\Milestone
     */
    public function issueEditMilestone($owner, $repo, $id, $body = null)
    {
        list($response) = $this->issueEditMilestoneWithHttpInfo($owner, $repo, $id, $body);
        return $response;
    }

    /**
     * Operation issueEditMilestoneWithHttpInfo
     *
     * Update a milestone
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  string $id the milestone to edit, identified by ID and if not available by name (required)
     * @param  \Efsa\Client\Gitea\Model\EditMilestoneOption $body (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\Milestone, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueEditMilestoneWithHttpInfo($owner, $repo, $id, $body = null)
    {
        $request = $this->issueEditMilestoneRequest($owner, $repo, $id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Efsa\Client\Gitea\Model\Milestone' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\Milestone', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\Milestone';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\Milestone',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueEditMilestoneAsync
     *
     * Update a milestone
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  string $id the milestone to edit, identified by ID and if not available by name (required)
     * @param  \Efsa\Client\Gitea\Model\EditMilestoneOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueEditMilestoneAsync($owner, $repo, $id, $body = null)
    {
        return $this->issueEditMilestoneAsyncWithHttpInfo($owner, $repo, $id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueEditMilestoneAsyncWithHttpInfo
     *
     * Update a milestone
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  string $id the milestone to edit, identified by ID and if not available by name (required)
     * @param  \Efsa\Client\Gitea\Model\EditMilestoneOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueEditMilestoneAsyncWithHttpInfo($owner, $repo, $id, $body = null)
    {
        $returnType = '\Efsa\Client\Gitea\Model\Milestone';
        $request = $this->issueEditMilestoneRequest($owner, $repo, $id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueEditMilestone'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  string $id the milestone to edit, identified by ID and if not available by name (required)
     * @param  \Efsa\Client\Gitea\Model\EditMilestoneOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueEditMilestoneRequest($owner, $repo, $id, $body = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueEditMilestone'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueEditMilestone'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling issueEditMilestone'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/milestones/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($body)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueGetComment
     *
     * Get a comment
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the comment (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\Comment
     */
    public function issueGetComment($owner, $repo, $id)
    {
        list($response) = $this->issueGetCommentWithHttpInfo($owner, $repo, $id);
        return $response;
    }

    /**
     * Operation issueGetCommentWithHttpInfo
     *
     * Get a comment
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the comment (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\Comment, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueGetCommentWithHttpInfo($owner, $repo, $id)
    {
        $request = $this->issueGetCommentRequest($owner, $repo, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Efsa\Client\Gitea\Model\Comment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\Comment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\Comment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\Comment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueGetCommentAsync
     *
     * Get a comment
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the comment (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueGetCommentAsync($owner, $repo, $id)
    {
        return $this->issueGetCommentAsyncWithHttpInfo($owner, $repo, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueGetCommentAsyncWithHttpInfo
     *
     * Get a comment
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the comment (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueGetCommentAsyncWithHttpInfo($owner, $repo, $id)
    {
        $returnType = '\Efsa\Client\Gitea\Model\Comment';
        $request = $this->issueGetCommentRequest($owner, $repo, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueGetComment'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the comment (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueGetCommentRequest($owner, $repo, $id)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueGetComment'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueGetComment'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling issueGetComment'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/comments/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueGetCommentReactions
     *
     * Get a list of reactions from a comment of an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the comment to edit (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\Reaction[]
     */
    public function issueGetCommentReactions($owner, $repo, $id)
    {
        list($response) = $this->issueGetCommentReactionsWithHttpInfo($owner, $repo, $id);
        return $response;
    }

    /**
     * Operation issueGetCommentReactionsWithHttpInfo
     *
     * Get a list of reactions from a comment of an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the comment to edit (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\Reaction[], HTTP status code, HTTP response headers (array of strings)
     */
    public function issueGetCommentReactionsWithHttpInfo($owner, $repo, $id)
    {
        $request = $this->issueGetCommentReactionsRequest($owner, $repo, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Efsa\Client\Gitea\Model\Reaction[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\Reaction[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\Reaction[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\Reaction[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueGetCommentReactionsAsync
     *
     * Get a list of reactions from a comment of an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the comment to edit (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueGetCommentReactionsAsync($owner, $repo, $id)
    {
        return $this->issueGetCommentReactionsAsyncWithHttpInfo($owner, $repo, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueGetCommentReactionsAsyncWithHttpInfo
     *
     * Get a list of reactions from a comment of an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the comment to edit (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueGetCommentReactionsAsyncWithHttpInfo($owner, $repo, $id)
    {
        $returnType = '\Efsa\Client\Gitea\Model\Reaction[]';
        $request = $this->issueGetCommentReactionsRequest($owner, $repo, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueGetCommentReactions'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the comment to edit (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueGetCommentReactionsRequest($owner, $repo, $id)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueGetCommentReactions'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueGetCommentReactions'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling issueGetCommentReactions'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/comments/{id}/reactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueGetComments
     *
     * List all comments on an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \DateTime $since if provided, only comments updated since the specified time are returned. (optional)
     * @param  \DateTime $before if provided, only comments updated before the provided time are returned. (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\Comment[]
     */
    public function issueGetComments($owner, $repo, $index, $since = null, $before = null)
    {
        list($response) = $this->issueGetCommentsWithHttpInfo($owner, $repo, $index, $since, $before);
        return $response;
    }

    /**
     * Operation issueGetCommentsWithHttpInfo
     *
     * List all comments on an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \DateTime $since if provided, only comments updated since the specified time are returned. (optional)
     * @param  \DateTime $before if provided, only comments updated before the provided time are returned. (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\Comment[], HTTP status code, HTTP response headers (array of strings)
     */
    public function issueGetCommentsWithHttpInfo($owner, $repo, $index, $since = null, $before = null)
    {
        $request = $this->issueGetCommentsRequest($owner, $repo, $index, $since, $before);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Efsa\Client\Gitea\Model\Comment[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\Comment[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\Comment[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\Comment[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueGetCommentsAsync
     *
     * List all comments on an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \DateTime $since if provided, only comments updated since the specified time are returned. (optional)
     * @param  \DateTime $before if provided, only comments updated before the provided time are returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueGetCommentsAsync($owner, $repo, $index, $since = null, $before = null)
    {
        return $this->issueGetCommentsAsyncWithHttpInfo($owner, $repo, $index, $since, $before)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueGetCommentsAsyncWithHttpInfo
     *
     * List all comments on an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \DateTime $since if provided, only comments updated since the specified time are returned. (optional)
     * @param  \DateTime $before if provided, only comments updated before the provided time are returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueGetCommentsAsyncWithHttpInfo($owner, $repo, $index, $since = null, $before = null)
    {
        $returnType = '\Efsa\Client\Gitea\Model\Comment[]';
        $request = $this->issueGetCommentsRequest($owner, $repo, $index, $since, $before);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueGetComments'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \DateTime $since if provided, only comments updated since the specified time are returned. (optional)
     * @param  \DateTime $before if provided, only comments updated before the provided time are returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueGetCommentsRequest($owner, $repo, $index, $since = null, $before = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueGetComments'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueGetComments'
            );
        }
        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling issueGetComments'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/{index}/comments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($since)) {
            $since = ObjectSerializer::serializeCollection($since, '', true);
        }
        if ($since !== null) {
            $queryParams['since'] = $since;
        }
        // query params
        if (is_array($before)) {
            $before = ObjectSerializer::serializeCollection($before, '', true);
        }
        if ($before !== null) {
            $queryParams['before'] = $before;
        }


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueGetCommentsAndTimeline
     *
     * List all comments and events on an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \DateTime $since if provided, only comments updated since the specified time are returned. (optional)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     * @param  \DateTime $before if provided, only comments updated before the provided time are returned. (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\TimelineComment[]
     */
    public function issueGetCommentsAndTimeline($owner, $repo, $index, $since = null, $page = null, $limit = null, $before = null)
    {
        list($response) = $this->issueGetCommentsAndTimelineWithHttpInfo($owner, $repo, $index, $since, $page, $limit, $before);
        return $response;
    }

    /**
     * Operation issueGetCommentsAndTimelineWithHttpInfo
     *
     * List all comments and events on an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \DateTime $since if provided, only comments updated since the specified time are returned. (optional)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     * @param  \DateTime $before if provided, only comments updated before the provided time are returned. (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\TimelineComment[], HTTP status code, HTTP response headers (array of strings)
     */
    public function issueGetCommentsAndTimelineWithHttpInfo($owner, $repo, $index, $since = null, $page = null, $limit = null, $before = null)
    {
        $request = $this->issueGetCommentsAndTimelineRequest($owner, $repo, $index, $since, $page, $limit, $before);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Efsa\Client\Gitea\Model\TimelineComment[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\TimelineComment[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\TimelineComment[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\TimelineComment[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueGetCommentsAndTimelineAsync
     *
     * List all comments and events on an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \DateTime $since if provided, only comments updated since the specified time are returned. (optional)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     * @param  \DateTime $before if provided, only comments updated before the provided time are returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueGetCommentsAndTimelineAsync($owner, $repo, $index, $since = null, $page = null, $limit = null, $before = null)
    {
        return $this->issueGetCommentsAndTimelineAsyncWithHttpInfo($owner, $repo, $index, $since, $page, $limit, $before)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueGetCommentsAndTimelineAsyncWithHttpInfo
     *
     * List all comments and events on an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \DateTime $since if provided, only comments updated since the specified time are returned. (optional)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     * @param  \DateTime $before if provided, only comments updated before the provided time are returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueGetCommentsAndTimelineAsyncWithHttpInfo($owner, $repo, $index, $since = null, $page = null, $limit = null, $before = null)
    {
        $returnType = '\Efsa\Client\Gitea\Model\TimelineComment[]';
        $request = $this->issueGetCommentsAndTimelineRequest($owner, $repo, $index, $since, $page, $limit, $before);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueGetCommentsAndTimeline'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \DateTime $since if provided, only comments updated since the specified time are returned. (optional)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     * @param  \DateTime $before if provided, only comments updated before the provided time are returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueGetCommentsAndTimelineRequest($owner, $repo, $index, $since = null, $page = null, $limit = null, $before = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueGetCommentsAndTimeline'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueGetCommentsAndTimeline'
            );
        }
        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling issueGetCommentsAndTimeline'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/{index}/timeline';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($since)) {
            $since = ObjectSerializer::serializeCollection($since, '', true);
        }
        if ($since !== null) {
            $queryParams['since'] = $since;
        }
        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }
        // query params
        if (is_array($before)) {
            $before = ObjectSerializer::serializeCollection($before, '', true);
        }
        if ($before !== null) {
            $queryParams['before'] = $before;
        }


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueGetIssue
     *
     * Get an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to get (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\Issue
     */
    public function issueGetIssue($owner, $repo, $index)
    {
        list($response) = $this->issueGetIssueWithHttpInfo($owner, $repo, $index);
        return $response;
    }

    /**
     * Operation issueGetIssueWithHttpInfo
     *
     * Get an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to get (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\Issue, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueGetIssueWithHttpInfo($owner, $repo, $index)
    {
        $request = $this->issueGetIssueRequest($owner, $repo, $index);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Efsa\Client\Gitea\Model\Issue' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\Issue', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\Issue';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\Issue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueGetIssueAsync
     *
     * Get an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to get (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueGetIssueAsync($owner, $repo, $index)
    {
        return $this->issueGetIssueAsyncWithHttpInfo($owner, $repo, $index)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueGetIssueAsyncWithHttpInfo
     *
     * Get an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to get (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueGetIssueAsyncWithHttpInfo($owner, $repo, $index)
    {
        $returnType = '\Efsa\Client\Gitea\Model\Issue';
        $request = $this->issueGetIssueRequest($owner, $repo, $index);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueGetIssue'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to get (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueGetIssueRequest($owner, $repo, $index)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueGetIssue'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueGetIssue'
            );
        }
        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling issueGetIssue'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/{index}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueGetIssueReactions
     *
     * Get a list reactions of an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\Reaction[]
     */
    public function issueGetIssueReactions($owner, $repo, $index, $page = null, $limit = null)
    {
        list($response) = $this->issueGetIssueReactionsWithHttpInfo($owner, $repo, $index, $page, $limit);
        return $response;
    }

    /**
     * Operation issueGetIssueReactionsWithHttpInfo
     *
     * Get a list reactions of an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\Reaction[], HTTP status code, HTTP response headers (array of strings)
     */
    public function issueGetIssueReactionsWithHttpInfo($owner, $repo, $index, $page = null, $limit = null)
    {
        $request = $this->issueGetIssueReactionsRequest($owner, $repo, $index, $page, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Efsa\Client\Gitea\Model\Reaction[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\Reaction[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\Reaction[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\Reaction[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueGetIssueReactionsAsync
     *
     * Get a list reactions of an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueGetIssueReactionsAsync($owner, $repo, $index, $page = null, $limit = null)
    {
        return $this->issueGetIssueReactionsAsyncWithHttpInfo($owner, $repo, $index, $page, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueGetIssueReactionsAsyncWithHttpInfo
     *
     * Get a list reactions of an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueGetIssueReactionsAsyncWithHttpInfo($owner, $repo, $index, $page = null, $limit = null)
    {
        $returnType = '\Efsa\Client\Gitea\Model\Reaction[]';
        $request = $this->issueGetIssueReactionsRequest($owner, $repo, $index, $page, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueGetIssueReactions'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueGetIssueReactionsRequest($owner, $repo, $index, $page = null, $limit = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueGetIssueReactions'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueGetIssueReactions'
            );
        }
        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling issueGetIssueReactions'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/{index}/reactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueGetLabel
     *
     * Get a single label
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the label to get (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\Label
     */
    public function issueGetLabel($owner, $repo, $id)
    {
        list($response) = $this->issueGetLabelWithHttpInfo($owner, $repo, $id);
        return $response;
    }

    /**
     * Operation issueGetLabelWithHttpInfo
     *
     * Get a single label
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the label to get (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\Label, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueGetLabelWithHttpInfo($owner, $repo, $id)
    {
        $request = $this->issueGetLabelRequest($owner, $repo, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Efsa\Client\Gitea\Model\Label' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\Label', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\Label';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\Label',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueGetLabelAsync
     *
     * Get a single label
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the label to get (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueGetLabelAsync($owner, $repo, $id)
    {
        return $this->issueGetLabelAsyncWithHttpInfo($owner, $repo, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueGetLabelAsyncWithHttpInfo
     *
     * Get a single label
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the label to get (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueGetLabelAsyncWithHttpInfo($owner, $repo, $id)
    {
        $returnType = '\Efsa\Client\Gitea\Model\Label';
        $request = $this->issueGetLabelRequest($owner, $repo, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueGetLabel'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the label to get (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueGetLabelRequest($owner, $repo, $id)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueGetLabel'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueGetLabel'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling issueGetLabel'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/labels/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueGetLabels
     *
     * Get an issue&#39;s labels
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\Label[]
     */
    public function issueGetLabels($owner, $repo, $index)
    {
        list($response) = $this->issueGetLabelsWithHttpInfo($owner, $repo, $index);
        return $response;
    }

    /**
     * Operation issueGetLabelsWithHttpInfo
     *
     * Get an issue&#39;s labels
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\Label[], HTTP status code, HTTP response headers (array of strings)
     */
    public function issueGetLabelsWithHttpInfo($owner, $repo, $index)
    {
        $request = $this->issueGetLabelsRequest($owner, $repo, $index);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Efsa\Client\Gitea\Model\Label[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\Label[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\Label[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\Label[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueGetLabelsAsync
     *
     * Get an issue&#39;s labels
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueGetLabelsAsync($owner, $repo, $index)
    {
        return $this->issueGetLabelsAsyncWithHttpInfo($owner, $repo, $index)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueGetLabelsAsyncWithHttpInfo
     *
     * Get an issue&#39;s labels
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueGetLabelsAsyncWithHttpInfo($owner, $repo, $index)
    {
        $returnType = '\Efsa\Client\Gitea\Model\Label[]';
        $request = $this->issueGetLabelsRequest($owner, $repo, $index);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueGetLabels'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueGetLabelsRequest($owner, $repo, $index)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueGetLabels'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueGetLabels'
            );
        }
        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling issueGetLabels'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/{index}/labels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueGetMilestone
     *
     * Get a milestone
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  string $id the milestone to get, identified by ID and if not available by name (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\Milestone
     */
    public function issueGetMilestone($owner, $repo, $id)
    {
        list($response) = $this->issueGetMilestoneWithHttpInfo($owner, $repo, $id);
        return $response;
    }

    /**
     * Operation issueGetMilestoneWithHttpInfo
     *
     * Get a milestone
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  string $id the milestone to get, identified by ID and if not available by name (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\Milestone, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueGetMilestoneWithHttpInfo($owner, $repo, $id)
    {
        $request = $this->issueGetMilestoneRequest($owner, $repo, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Efsa\Client\Gitea\Model\Milestone' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\Milestone', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\Milestone';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\Milestone',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueGetMilestoneAsync
     *
     * Get a milestone
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  string $id the milestone to get, identified by ID and if not available by name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueGetMilestoneAsync($owner, $repo, $id)
    {
        return $this->issueGetMilestoneAsyncWithHttpInfo($owner, $repo, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueGetMilestoneAsyncWithHttpInfo
     *
     * Get a milestone
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  string $id the milestone to get, identified by ID and if not available by name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueGetMilestoneAsyncWithHttpInfo($owner, $repo, $id)
    {
        $returnType = '\Efsa\Client\Gitea\Model\Milestone';
        $request = $this->issueGetMilestoneRequest($owner, $repo, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueGetMilestone'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  string $id the milestone to get, identified by ID and if not available by name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueGetMilestoneRequest($owner, $repo, $id)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueGetMilestone'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueGetMilestone'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling issueGetMilestone'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/milestones/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueGetMilestonesList
     *
     * Get all of a repository&#39;s opened milestones
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  string $state Milestone state, Recognised values are open, closed and all. Defaults to \&quot;open\&quot; (optional)
     * @param  string $name filter by milestone name (optional)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\Milestone[]
     */
    public function issueGetMilestonesList($owner, $repo, $state = null, $name = null, $page = null, $limit = null)
    {
        list($response) = $this->issueGetMilestonesListWithHttpInfo($owner, $repo, $state, $name, $page, $limit);
        return $response;
    }

    /**
     * Operation issueGetMilestonesListWithHttpInfo
     *
     * Get all of a repository&#39;s opened milestones
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  string $state Milestone state, Recognised values are open, closed and all. Defaults to \&quot;open\&quot; (optional)
     * @param  string $name filter by milestone name (optional)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\Milestone[], HTTP status code, HTTP response headers (array of strings)
     */
    public function issueGetMilestonesListWithHttpInfo($owner, $repo, $state = null, $name = null, $page = null, $limit = null)
    {
        $request = $this->issueGetMilestonesListRequest($owner, $repo, $state, $name, $page, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Efsa\Client\Gitea\Model\Milestone[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\Milestone[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\Milestone[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\Milestone[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueGetMilestonesListAsync
     *
     * Get all of a repository&#39;s opened milestones
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  string $state Milestone state, Recognised values are open, closed and all. Defaults to \&quot;open\&quot; (optional)
     * @param  string $name filter by milestone name (optional)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueGetMilestonesListAsync($owner, $repo, $state = null, $name = null, $page = null, $limit = null)
    {
        return $this->issueGetMilestonesListAsyncWithHttpInfo($owner, $repo, $state, $name, $page, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueGetMilestonesListAsyncWithHttpInfo
     *
     * Get all of a repository&#39;s opened milestones
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  string $state Milestone state, Recognised values are open, closed and all. Defaults to \&quot;open\&quot; (optional)
     * @param  string $name filter by milestone name (optional)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueGetMilestonesListAsyncWithHttpInfo($owner, $repo, $state = null, $name = null, $page = null, $limit = null)
    {
        $returnType = '\Efsa\Client\Gitea\Model\Milestone[]';
        $request = $this->issueGetMilestonesListRequest($owner, $repo, $state, $name, $page, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueGetMilestonesList'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  string $state Milestone state, Recognised values are open, closed and all. Defaults to \&quot;open\&quot; (optional)
     * @param  string $name filter by milestone name (optional)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueGetMilestonesListRequest($owner, $repo, $state = null, $name = null, $page = null, $limit = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueGetMilestonesList'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueGetMilestonesList'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/milestones';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($state)) {
            $state = ObjectSerializer::serializeCollection($state, '', true);
        }
        if ($state !== null) {
            $queryParams['state'] = $state;
        }
        // query params
        if (is_array($name)) {
            $name = ObjectSerializer::serializeCollection($name, '', true);
        }
        if ($name !== null) {
            $queryParams['name'] = $name;
        }
        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueGetRepoComments
     *
     * List all comments in a repository
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  \DateTime $since if provided, only comments updated since the provided time are returned. (optional)
     * @param  \DateTime $before if provided, only comments updated before the provided time are returned. (optional)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\Comment[]
     */
    public function issueGetRepoComments($owner, $repo, $since = null, $before = null, $page = null, $limit = null)
    {
        list($response) = $this->issueGetRepoCommentsWithHttpInfo($owner, $repo, $since, $before, $page, $limit);
        return $response;
    }

    /**
     * Operation issueGetRepoCommentsWithHttpInfo
     *
     * List all comments in a repository
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  \DateTime $since if provided, only comments updated since the provided time are returned. (optional)
     * @param  \DateTime $before if provided, only comments updated before the provided time are returned. (optional)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\Comment[], HTTP status code, HTTP response headers (array of strings)
     */
    public function issueGetRepoCommentsWithHttpInfo($owner, $repo, $since = null, $before = null, $page = null, $limit = null)
    {
        $request = $this->issueGetRepoCommentsRequest($owner, $repo, $since, $before, $page, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Efsa\Client\Gitea\Model\Comment[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\Comment[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\Comment[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\Comment[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueGetRepoCommentsAsync
     *
     * List all comments in a repository
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  \DateTime $since if provided, only comments updated since the provided time are returned. (optional)
     * @param  \DateTime $before if provided, only comments updated before the provided time are returned. (optional)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueGetRepoCommentsAsync($owner, $repo, $since = null, $before = null, $page = null, $limit = null)
    {
        return $this->issueGetRepoCommentsAsyncWithHttpInfo($owner, $repo, $since, $before, $page, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueGetRepoCommentsAsyncWithHttpInfo
     *
     * List all comments in a repository
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  \DateTime $since if provided, only comments updated since the provided time are returned. (optional)
     * @param  \DateTime $before if provided, only comments updated before the provided time are returned. (optional)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueGetRepoCommentsAsyncWithHttpInfo($owner, $repo, $since = null, $before = null, $page = null, $limit = null)
    {
        $returnType = '\Efsa\Client\Gitea\Model\Comment[]';
        $request = $this->issueGetRepoCommentsRequest($owner, $repo, $since, $before, $page, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueGetRepoComments'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  \DateTime $since if provided, only comments updated since the provided time are returned. (optional)
     * @param  \DateTime $before if provided, only comments updated before the provided time are returned. (optional)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueGetRepoCommentsRequest($owner, $repo, $since = null, $before = null, $page = null, $limit = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueGetRepoComments'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueGetRepoComments'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/comments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($since)) {
            $since = ObjectSerializer::serializeCollection($since, '', true);
        }
        if ($since !== null) {
            $queryParams['since'] = $since;
        }
        // query params
        if (is_array($before)) {
            $before = ObjectSerializer::serializeCollection($before, '', true);
        }
        if ($before !== null) {
            $queryParams['before'] = $before;
        }
        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueListIssues
     *
     * List a repository&#39;s issues
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  string $state whether issue is open or closed (optional)
     * @param  string $labels comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded (optional)
     * @param  string $q search string (optional)
     * @param  string $type filter by type (issues / pulls) if set (optional)
     * @param  string $milestones comma separated list of milestone names or ids. It uses names and fall back to ids. Fetch only issues that have any of this milestones. Non existent milestones are discarded (optional)
     * @param  \DateTime $since Only show items updated after the given time. This is a timestamp in RFC 3339 format (optional)
     * @param  \DateTime $before Only show items updated before the given time. This is a timestamp in RFC 3339 format (optional)
     * @param  string $createdBy Only show items which were created by the the given user (optional)
     * @param  string $assignedBy Only show items for which the given user is assigned (optional)
     * @param  string $mentionedBy Only show items in which the given user was mentioned (optional)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\Issue[]
     */
    public function issueListIssues($owner, $repo, $state = null, $labels = null, $q = null, $type = null, $milestones = null, $since = null, $before = null, $createdBy = null, $assignedBy = null, $mentionedBy = null, $page = null, $limit = null)
    {
        list($response) = $this->issueListIssuesWithHttpInfo($owner, $repo, $state, $labels, $q, $type, $milestones, $since, $before, $createdBy, $assignedBy, $mentionedBy, $page, $limit);
        return $response;
    }

    /**
     * Operation issueListIssuesWithHttpInfo
     *
     * List a repository&#39;s issues
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  string $state whether issue is open or closed (optional)
     * @param  string $labels comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded (optional)
     * @param  string $q search string (optional)
     * @param  string $type filter by type (issues / pulls) if set (optional)
     * @param  string $milestones comma separated list of milestone names or ids. It uses names and fall back to ids. Fetch only issues that have any of this milestones. Non existent milestones are discarded (optional)
     * @param  \DateTime $since Only show items updated after the given time. This is a timestamp in RFC 3339 format (optional)
     * @param  \DateTime $before Only show items updated before the given time. This is a timestamp in RFC 3339 format (optional)
     * @param  string $createdBy Only show items which were created by the the given user (optional)
     * @param  string $assignedBy Only show items for which the given user is assigned (optional)
     * @param  string $mentionedBy Only show items in which the given user was mentioned (optional)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\Issue[], HTTP status code, HTTP response headers (array of strings)
     */
    public function issueListIssuesWithHttpInfo($owner, $repo, $state = null, $labels = null, $q = null, $type = null, $milestones = null, $since = null, $before = null, $createdBy = null, $assignedBy = null, $mentionedBy = null, $page = null, $limit = null)
    {
        $request = $this->issueListIssuesRequest($owner, $repo, $state, $labels, $q, $type, $milestones, $since, $before, $createdBy, $assignedBy, $mentionedBy, $page, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Efsa\Client\Gitea\Model\Issue[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\Issue[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\Issue[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\Issue[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueListIssuesAsync
     *
     * List a repository&#39;s issues
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  string $state whether issue is open or closed (optional)
     * @param  string $labels comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded (optional)
     * @param  string $q search string (optional)
     * @param  string $type filter by type (issues / pulls) if set (optional)
     * @param  string $milestones comma separated list of milestone names or ids. It uses names and fall back to ids. Fetch only issues that have any of this milestones. Non existent milestones are discarded (optional)
     * @param  \DateTime $since Only show items updated after the given time. This is a timestamp in RFC 3339 format (optional)
     * @param  \DateTime $before Only show items updated before the given time. This is a timestamp in RFC 3339 format (optional)
     * @param  string $createdBy Only show items which were created by the the given user (optional)
     * @param  string $assignedBy Only show items for which the given user is assigned (optional)
     * @param  string $mentionedBy Only show items in which the given user was mentioned (optional)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueListIssuesAsync($owner, $repo, $state = null, $labels = null, $q = null, $type = null, $milestones = null, $since = null, $before = null, $createdBy = null, $assignedBy = null, $mentionedBy = null, $page = null, $limit = null)
    {
        return $this->issueListIssuesAsyncWithHttpInfo($owner, $repo, $state, $labels, $q, $type, $milestones, $since, $before, $createdBy, $assignedBy, $mentionedBy, $page, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueListIssuesAsyncWithHttpInfo
     *
     * List a repository&#39;s issues
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  string $state whether issue is open or closed (optional)
     * @param  string $labels comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded (optional)
     * @param  string $q search string (optional)
     * @param  string $type filter by type (issues / pulls) if set (optional)
     * @param  string $milestones comma separated list of milestone names or ids. It uses names and fall back to ids. Fetch only issues that have any of this milestones. Non existent milestones are discarded (optional)
     * @param  \DateTime $since Only show items updated after the given time. This is a timestamp in RFC 3339 format (optional)
     * @param  \DateTime $before Only show items updated before the given time. This is a timestamp in RFC 3339 format (optional)
     * @param  string $createdBy Only show items which were created by the the given user (optional)
     * @param  string $assignedBy Only show items for which the given user is assigned (optional)
     * @param  string $mentionedBy Only show items in which the given user was mentioned (optional)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueListIssuesAsyncWithHttpInfo($owner, $repo, $state = null, $labels = null, $q = null, $type = null, $milestones = null, $since = null, $before = null, $createdBy = null, $assignedBy = null, $mentionedBy = null, $page = null, $limit = null)
    {
        $returnType = '\Efsa\Client\Gitea\Model\Issue[]';
        $request = $this->issueListIssuesRequest($owner, $repo, $state, $labels, $q, $type, $milestones, $since, $before, $createdBy, $assignedBy, $mentionedBy, $page, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueListIssues'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  string $state whether issue is open or closed (optional)
     * @param  string $labels comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded (optional)
     * @param  string $q search string (optional)
     * @param  string $type filter by type (issues / pulls) if set (optional)
     * @param  string $milestones comma separated list of milestone names or ids. It uses names and fall back to ids. Fetch only issues that have any of this milestones. Non existent milestones are discarded (optional)
     * @param  \DateTime $since Only show items updated after the given time. This is a timestamp in RFC 3339 format (optional)
     * @param  \DateTime $before Only show items updated before the given time. This is a timestamp in RFC 3339 format (optional)
     * @param  string $createdBy Only show items which were created by the the given user (optional)
     * @param  string $assignedBy Only show items for which the given user is assigned (optional)
     * @param  string $mentionedBy Only show items in which the given user was mentioned (optional)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueListIssuesRequest($owner, $repo, $state = null, $labels = null, $q = null, $type = null, $milestones = null, $since = null, $before = null, $createdBy = null, $assignedBy = null, $mentionedBy = null, $page = null, $limit = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueListIssues'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueListIssues'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($state)) {
            $state = ObjectSerializer::serializeCollection($state, '', true);
        }
        if ($state !== null) {
            $queryParams['state'] = $state;
        }
        // query params
        if (is_array($labels)) {
            $labels = ObjectSerializer::serializeCollection($labels, '', true);
        }
        if ($labels !== null) {
            $queryParams['labels'] = $labels;
        }
        // query params
        if (is_array($q)) {
            $q = ObjectSerializer::serializeCollection($q, '', true);
        }
        if ($q !== null) {
            $queryParams['q'] = $q;
        }
        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, '', true);
        }
        if ($type !== null) {
            $queryParams['type'] = $type;
        }
        // query params
        if (is_array($milestones)) {
            $milestones = ObjectSerializer::serializeCollection($milestones, '', true);
        }
        if ($milestones !== null) {
            $queryParams['milestones'] = $milestones;
        }
        // query params
        if (is_array($since)) {
            $since = ObjectSerializer::serializeCollection($since, '', true);
        }
        if ($since !== null) {
            $queryParams['since'] = $since;
        }
        // query params
        if (is_array($before)) {
            $before = ObjectSerializer::serializeCollection($before, '', true);
        }
        if ($before !== null) {
            $queryParams['before'] = $before;
        }
        // query params
        if (is_array($createdBy)) {
            $createdBy = ObjectSerializer::serializeCollection($createdBy, '', true);
        }
        if ($createdBy !== null) {
            $queryParams['created_by'] = $createdBy;
        }
        // query params
        if (is_array($assignedBy)) {
            $assignedBy = ObjectSerializer::serializeCollection($assignedBy, '', true);
        }
        if ($assignedBy !== null) {
            $queryParams['assigned_by'] = $assignedBy;
        }
        // query params
        if (is_array($mentionedBy)) {
            $mentionedBy = ObjectSerializer::serializeCollection($mentionedBy, '', true);
        }
        if ($mentionedBy !== null) {
            $queryParams['mentioned_by'] = $mentionedBy;
        }
        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueListLabels
     *
     * Get all of a repository&#39;s labels
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\Label[]
     */
    public function issueListLabels($owner, $repo, $page = null, $limit = null)
    {
        list($response) = $this->issueListLabelsWithHttpInfo($owner, $repo, $page, $limit);
        return $response;
    }

    /**
     * Operation issueListLabelsWithHttpInfo
     *
     * Get all of a repository&#39;s labels
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\Label[], HTTP status code, HTTP response headers (array of strings)
     */
    public function issueListLabelsWithHttpInfo($owner, $repo, $page = null, $limit = null)
    {
        $request = $this->issueListLabelsRequest($owner, $repo, $page, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Efsa\Client\Gitea\Model\Label[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\Label[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\Label[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\Label[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueListLabelsAsync
     *
     * Get all of a repository&#39;s labels
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueListLabelsAsync($owner, $repo, $page = null, $limit = null)
    {
        return $this->issueListLabelsAsyncWithHttpInfo($owner, $repo, $page, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueListLabelsAsyncWithHttpInfo
     *
     * Get all of a repository&#39;s labels
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueListLabelsAsyncWithHttpInfo($owner, $repo, $page = null, $limit = null)
    {
        $returnType = '\Efsa\Client\Gitea\Model\Label[]';
        $request = $this->issueListLabelsRequest($owner, $repo, $page, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueListLabels'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueListLabelsRequest($owner, $repo, $page = null, $limit = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueListLabels'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueListLabels'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/labels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issuePostCommentReaction
     *
     * Add a reaction to a comment of an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the comment to edit (required)
     * @param  \Efsa\Client\Gitea\Model\EditReactionOption $content content (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\Reaction|\Efsa\Client\Gitea\Model\Reaction
     */
    public function issuePostCommentReaction($owner, $repo, $id, $content = null)
    {
        list($response) = $this->issuePostCommentReactionWithHttpInfo($owner, $repo, $id, $content);
        return $response;
    }

    /**
     * Operation issuePostCommentReactionWithHttpInfo
     *
     * Add a reaction to a comment of an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the comment to edit (required)
     * @param  \Efsa\Client\Gitea\Model\EditReactionOption $content (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\Reaction|\Efsa\Client\Gitea\Model\Reaction, HTTP status code, HTTP response headers (array of strings)
     */
    public function issuePostCommentReactionWithHttpInfo($owner, $repo, $id, $content = null)
    {
        $request = $this->issuePostCommentReactionRequest($owner, $repo, $id, $content);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Efsa\Client\Gitea\Model\Reaction' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\Reaction', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 201:
                    if ('\Efsa\Client\Gitea\Model\Reaction' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\Reaction', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\Reaction';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\Reaction',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\Reaction',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issuePostCommentReactionAsync
     *
     * Add a reaction to a comment of an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the comment to edit (required)
     * @param  \Efsa\Client\Gitea\Model\EditReactionOption $content (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issuePostCommentReactionAsync($owner, $repo, $id, $content = null)
    {
        return $this->issuePostCommentReactionAsyncWithHttpInfo($owner, $repo, $id, $content)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issuePostCommentReactionAsyncWithHttpInfo
     *
     * Add a reaction to a comment of an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the comment to edit (required)
     * @param  \Efsa\Client\Gitea\Model\EditReactionOption $content (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issuePostCommentReactionAsyncWithHttpInfo($owner, $repo, $id, $content = null)
    {
        $returnType = '\Efsa\Client\Gitea\Model\Reaction';
        $request = $this->issuePostCommentReactionRequest($owner, $repo, $id, $content);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issuePostCommentReaction'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $id id of the comment to edit (required)
     * @param  \Efsa\Client\Gitea\Model\EditReactionOption $content (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issuePostCommentReactionRequest($owner, $repo, $id, $content = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issuePostCommentReaction'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issuePostCommentReaction'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling issuePostCommentReaction'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/comments/{id}/reactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($content)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($content));
            } else {
                $httpBody = $content;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issuePostIssueReaction
     *
     * Add a reaction to an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \Efsa\Client\Gitea\Model\EditReactionOption $content content (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\Reaction|\Efsa\Client\Gitea\Model\Reaction
     */
    public function issuePostIssueReaction($owner, $repo, $index, $content = null)
    {
        list($response) = $this->issuePostIssueReactionWithHttpInfo($owner, $repo, $index, $content);
        return $response;
    }

    /**
     * Operation issuePostIssueReactionWithHttpInfo
     *
     * Add a reaction to an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \Efsa\Client\Gitea\Model\EditReactionOption $content (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\Reaction|\Efsa\Client\Gitea\Model\Reaction, HTTP status code, HTTP response headers (array of strings)
     */
    public function issuePostIssueReactionWithHttpInfo($owner, $repo, $index, $content = null)
    {
        $request = $this->issuePostIssueReactionRequest($owner, $repo, $index, $content);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Efsa\Client\Gitea\Model\Reaction' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\Reaction', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 201:
                    if ('\Efsa\Client\Gitea\Model\Reaction' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\Reaction', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\Reaction';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\Reaction',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\Reaction',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issuePostIssueReactionAsync
     *
     * Add a reaction to an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \Efsa\Client\Gitea\Model\EditReactionOption $content (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issuePostIssueReactionAsync($owner, $repo, $index, $content = null)
    {
        return $this->issuePostIssueReactionAsyncWithHttpInfo($owner, $repo, $index, $content)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issuePostIssueReactionAsyncWithHttpInfo
     *
     * Add a reaction to an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \Efsa\Client\Gitea\Model\EditReactionOption $content (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issuePostIssueReactionAsyncWithHttpInfo($owner, $repo, $index, $content = null)
    {
        $returnType = '\Efsa\Client\Gitea\Model\Reaction';
        $request = $this->issuePostIssueReactionRequest($owner, $repo, $index, $content);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issuePostIssueReaction'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \Efsa\Client\Gitea\Model\EditReactionOption $content (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issuePostIssueReactionRequest($owner, $repo, $index, $content = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issuePostIssueReaction'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issuePostIssueReaction'
            );
        }
        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling issuePostIssueReaction'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/{index}/reactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($content)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($content));
            } else {
                $httpBody = $content;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueRemoveLabel
     *
     * Remove a label from an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  int $id id of the label to remove (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function issueRemoveLabel($owner, $repo, $index, $id)
    {
        $this->issueRemoveLabelWithHttpInfo($owner, $repo, $index, $id);
    }

    /**
     * Operation issueRemoveLabelWithHttpInfo
     *
     * Remove a label from an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  int $id id of the label to remove (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueRemoveLabelWithHttpInfo($owner, $repo, $index, $id)
    {
        $request = $this->issueRemoveLabelRequest($owner, $repo, $index, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation issueRemoveLabelAsync
     *
     * Remove a label from an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  int $id id of the label to remove (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueRemoveLabelAsync($owner, $repo, $index, $id)
    {
        return $this->issueRemoveLabelAsyncWithHttpInfo($owner, $repo, $index, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueRemoveLabelAsyncWithHttpInfo
     *
     * Remove a label from an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  int $id id of the label to remove (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueRemoveLabelAsyncWithHttpInfo($owner, $repo, $index, $id)
    {
        $returnType = '';
        $request = $this->issueRemoveLabelRequest($owner, $repo, $index, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueRemoveLabel'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  int $id id of the label to remove (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueRemoveLabelRequest($owner, $repo, $index, $id)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueRemoveLabel'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueRemoveLabel'
            );
        }
        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling issueRemoveLabel'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling issueRemoveLabel'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/{index}/labels/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueReplaceLabels
     *
     * Replace an issue&#39;s labels
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \Efsa\Client\Gitea\Model\IssueLabelsOption $body body (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\Label[]
     */
    public function issueReplaceLabels($owner, $repo, $index, $body = null)
    {
        list($response) = $this->issueReplaceLabelsWithHttpInfo($owner, $repo, $index, $body);
        return $response;
    }

    /**
     * Operation issueReplaceLabelsWithHttpInfo
     *
     * Replace an issue&#39;s labels
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \Efsa\Client\Gitea\Model\IssueLabelsOption $body (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\Label[], HTTP status code, HTTP response headers (array of strings)
     */
    public function issueReplaceLabelsWithHttpInfo($owner, $repo, $index, $body = null)
    {
        $request = $this->issueReplaceLabelsRequest($owner, $repo, $index, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Efsa\Client\Gitea\Model\Label[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\Label[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\Label[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\Label[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueReplaceLabelsAsync
     *
     * Replace an issue&#39;s labels
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \Efsa\Client\Gitea\Model\IssueLabelsOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueReplaceLabelsAsync($owner, $repo, $index, $body = null)
    {
        return $this->issueReplaceLabelsAsyncWithHttpInfo($owner, $repo, $index, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueReplaceLabelsAsyncWithHttpInfo
     *
     * Replace an issue&#39;s labels
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \Efsa\Client\Gitea\Model\IssueLabelsOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueReplaceLabelsAsyncWithHttpInfo($owner, $repo, $index, $body = null)
    {
        $returnType = '\Efsa\Client\Gitea\Model\Label[]';
        $request = $this->issueReplaceLabelsRequest($owner, $repo, $index, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueReplaceLabels'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  \Efsa\Client\Gitea\Model\IssueLabelsOption $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueReplaceLabelsRequest($owner, $repo, $index, $body = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueReplaceLabels'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueReplaceLabels'
            );
        }
        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling issueReplaceLabels'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/{index}/labels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($body)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueResetTime
     *
     * Reset a tracked time of an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to add tracked time to (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function issueResetTime($owner, $repo, $index)
    {
        $this->issueResetTimeWithHttpInfo($owner, $repo, $index);
    }

    /**
     * Operation issueResetTimeWithHttpInfo
     *
     * Reset a tracked time of an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to add tracked time to (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueResetTimeWithHttpInfo($owner, $repo, $index)
    {
        $request = $this->issueResetTimeRequest($owner, $repo, $index);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation issueResetTimeAsync
     *
     * Reset a tracked time of an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to add tracked time to (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueResetTimeAsync($owner, $repo, $index)
    {
        return $this->issueResetTimeAsyncWithHttpInfo($owner, $repo, $index)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueResetTimeAsyncWithHttpInfo
     *
     * Reset a tracked time of an issue
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to add tracked time to (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueResetTimeAsyncWithHttpInfo($owner, $repo, $index)
    {
        $returnType = '';
        $request = $this->issueResetTimeRequest($owner, $repo, $index);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueResetTime'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to add tracked time to (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueResetTimeRequest($owner, $repo, $index)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueResetTime'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueResetTime'
            );
        }
        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling issueResetTime'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/{index}/times';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueSearchIssues
     *
     * Search for issues across the repositories that the user has access to
     *
     * @param  string $state whether issue is open or closed (optional)
     * @param  string $labels comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded (optional)
     * @param  string $milestones comma separated list of milestone names. Fetch only issues that have any of this milestones. Non existent are discarded (optional)
     * @param  string $q search string (optional)
     * @param  int $priorityRepoId repository to prioritize in the results (optional)
     * @param  string $type filter by type (issues / pulls) if set (optional)
     * @param  \DateTime $since Only show notifications updated after the given time. This is a timestamp in RFC 3339 format (optional)
     * @param  \DateTime $before Only show notifications updated before the given time. This is a timestamp in RFC 3339 format (optional)
     * @param  bool $assigned filter (issues / pulls) assigned to you, default is false (optional)
     * @param  bool $created filter (issues / pulls) created by you, default is false (optional)
     * @param  bool $mentioned filter (issues / pulls) mentioning you, default is false (optional)
     * @param  bool $reviewRequested filter pulls requesting your review, default is false (optional)
     * @param  string $owner filter by owner (optional)
     * @param  string $team filter by team (requires organization owner parameter to be provided) (optional)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\Issue[]
     */
    public function issueSearchIssues($state = null, $labels = null, $milestones = null, $q = null, $priorityRepoId = null, $type = null, $since = null, $before = null, $assigned = null, $created = null, $mentioned = null, $reviewRequested = null, $owner = null, $team = null, $page = null, $limit = null)
    {
        list($response) = $this->issueSearchIssuesWithHttpInfo($state, $labels, $milestones, $q, $priorityRepoId, $type, $since, $before, $assigned, $created, $mentioned, $reviewRequested, $owner, $team, $page, $limit);
        return $response;
    }

    /**
     * Operation issueSearchIssuesWithHttpInfo
     *
     * Search for issues across the repositories that the user has access to
     *
     * @param  string $state whether issue is open or closed (optional)
     * @param  string $labels comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded (optional)
     * @param  string $milestones comma separated list of milestone names. Fetch only issues that have any of this milestones. Non existent are discarded (optional)
     * @param  string $q search string (optional)
     * @param  int $priorityRepoId repository to prioritize in the results (optional)
     * @param  string $type filter by type (issues / pulls) if set (optional)
     * @param  \DateTime $since Only show notifications updated after the given time. This is a timestamp in RFC 3339 format (optional)
     * @param  \DateTime $before Only show notifications updated before the given time. This is a timestamp in RFC 3339 format (optional)
     * @param  bool $assigned filter (issues / pulls) assigned to you, default is false (optional)
     * @param  bool $created filter (issues / pulls) created by you, default is false (optional)
     * @param  bool $mentioned filter (issues / pulls) mentioning you, default is false (optional)
     * @param  bool $reviewRequested filter pulls requesting your review, default is false (optional)
     * @param  string $owner filter by owner (optional)
     * @param  string $team filter by team (requires organization owner parameter to be provided) (optional)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\Issue[], HTTP status code, HTTP response headers (array of strings)
     */
    public function issueSearchIssuesWithHttpInfo($state = null, $labels = null, $milestones = null, $q = null, $priorityRepoId = null, $type = null, $since = null, $before = null, $assigned = null, $created = null, $mentioned = null, $reviewRequested = null, $owner = null, $team = null, $page = null, $limit = null)
    {
        $request = $this->issueSearchIssuesRequest($state, $labels, $milestones, $q, $priorityRepoId, $type, $since, $before, $assigned, $created, $mentioned, $reviewRequested, $owner, $team, $page, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Efsa\Client\Gitea\Model\Issue[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\Issue[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\Issue[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\Issue[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueSearchIssuesAsync
     *
     * Search for issues across the repositories that the user has access to
     *
     * @param  string $state whether issue is open or closed (optional)
     * @param  string $labels comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded (optional)
     * @param  string $milestones comma separated list of milestone names. Fetch only issues that have any of this milestones. Non existent are discarded (optional)
     * @param  string $q search string (optional)
     * @param  int $priorityRepoId repository to prioritize in the results (optional)
     * @param  string $type filter by type (issues / pulls) if set (optional)
     * @param  \DateTime $since Only show notifications updated after the given time. This is a timestamp in RFC 3339 format (optional)
     * @param  \DateTime $before Only show notifications updated before the given time. This is a timestamp in RFC 3339 format (optional)
     * @param  bool $assigned filter (issues / pulls) assigned to you, default is false (optional)
     * @param  bool $created filter (issues / pulls) created by you, default is false (optional)
     * @param  bool $mentioned filter (issues / pulls) mentioning you, default is false (optional)
     * @param  bool $reviewRequested filter pulls requesting your review, default is false (optional)
     * @param  string $owner filter by owner (optional)
     * @param  string $team filter by team (requires organization owner parameter to be provided) (optional)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueSearchIssuesAsync($state = null, $labels = null, $milestones = null, $q = null, $priorityRepoId = null, $type = null, $since = null, $before = null, $assigned = null, $created = null, $mentioned = null, $reviewRequested = null, $owner = null, $team = null, $page = null, $limit = null)
    {
        return $this->issueSearchIssuesAsyncWithHttpInfo($state, $labels, $milestones, $q, $priorityRepoId, $type, $since, $before, $assigned, $created, $mentioned, $reviewRequested, $owner, $team, $page, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueSearchIssuesAsyncWithHttpInfo
     *
     * Search for issues across the repositories that the user has access to
     *
     * @param  string $state whether issue is open or closed (optional)
     * @param  string $labels comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded (optional)
     * @param  string $milestones comma separated list of milestone names. Fetch only issues that have any of this milestones. Non existent are discarded (optional)
     * @param  string $q search string (optional)
     * @param  int $priorityRepoId repository to prioritize in the results (optional)
     * @param  string $type filter by type (issues / pulls) if set (optional)
     * @param  \DateTime $since Only show notifications updated after the given time. This is a timestamp in RFC 3339 format (optional)
     * @param  \DateTime $before Only show notifications updated before the given time. This is a timestamp in RFC 3339 format (optional)
     * @param  bool $assigned filter (issues / pulls) assigned to you, default is false (optional)
     * @param  bool $created filter (issues / pulls) created by you, default is false (optional)
     * @param  bool $mentioned filter (issues / pulls) mentioning you, default is false (optional)
     * @param  bool $reviewRequested filter pulls requesting your review, default is false (optional)
     * @param  string $owner filter by owner (optional)
     * @param  string $team filter by team (requires organization owner parameter to be provided) (optional)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueSearchIssuesAsyncWithHttpInfo($state = null, $labels = null, $milestones = null, $q = null, $priorityRepoId = null, $type = null, $since = null, $before = null, $assigned = null, $created = null, $mentioned = null, $reviewRequested = null, $owner = null, $team = null, $page = null, $limit = null)
    {
        $returnType = '\Efsa\Client\Gitea\Model\Issue[]';
        $request = $this->issueSearchIssuesRequest($state, $labels, $milestones, $q, $priorityRepoId, $type, $since, $before, $assigned, $created, $mentioned, $reviewRequested, $owner, $team, $page, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueSearchIssues'
     *
     * @param  string $state whether issue is open or closed (optional)
     * @param  string $labels comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded (optional)
     * @param  string $milestones comma separated list of milestone names. Fetch only issues that have any of this milestones. Non existent are discarded (optional)
     * @param  string $q search string (optional)
     * @param  int $priorityRepoId repository to prioritize in the results (optional)
     * @param  string $type filter by type (issues / pulls) if set (optional)
     * @param  \DateTime $since Only show notifications updated after the given time. This is a timestamp in RFC 3339 format (optional)
     * @param  \DateTime $before Only show notifications updated before the given time. This is a timestamp in RFC 3339 format (optional)
     * @param  bool $assigned filter (issues / pulls) assigned to you, default is false (optional)
     * @param  bool $created filter (issues / pulls) created by you, default is false (optional)
     * @param  bool $mentioned filter (issues / pulls) mentioning you, default is false (optional)
     * @param  bool $reviewRequested filter pulls requesting your review, default is false (optional)
     * @param  string $owner filter by owner (optional)
     * @param  string $team filter by team (requires organization owner parameter to be provided) (optional)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueSearchIssuesRequest($state = null, $labels = null, $milestones = null, $q = null, $priorityRepoId = null, $type = null, $since = null, $before = null, $assigned = null, $created = null, $mentioned = null, $reviewRequested = null, $owner = null, $team = null, $page = null, $limit = null)
    {

        $resourcePath = '/repos/issues/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($state)) {
            $state = ObjectSerializer::serializeCollection($state, '', true);
        }
        if ($state !== null) {
            $queryParams['state'] = $state;
        }
        // query params
        if (is_array($labels)) {
            $labels = ObjectSerializer::serializeCollection($labels, '', true);
        }
        if ($labels !== null) {
            $queryParams['labels'] = $labels;
        }
        // query params
        if (is_array($milestones)) {
            $milestones = ObjectSerializer::serializeCollection($milestones, '', true);
        }
        if ($milestones !== null) {
            $queryParams['milestones'] = $milestones;
        }
        // query params
        if (is_array($q)) {
            $q = ObjectSerializer::serializeCollection($q, '', true);
        }
        if ($q !== null) {
            $queryParams['q'] = $q;
        }
        // query params
        if (is_array($priorityRepoId)) {
            $priorityRepoId = ObjectSerializer::serializeCollection($priorityRepoId, '', true);
        }
        if ($priorityRepoId !== null) {
            $queryParams['priority_repo_id'] = $priorityRepoId;
        }
        // query params
        if (is_array($type)) {
            $type = ObjectSerializer::serializeCollection($type, '', true);
        }
        if ($type !== null) {
            $queryParams['type'] = $type;
        }
        // query params
        if (is_array($since)) {
            $since = ObjectSerializer::serializeCollection($since, '', true);
        }
        if ($since !== null) {
            $queryParams['since'] = $since;
        }
        // query params
        if (is_array($before)) {
            $before = ObjectSerializer::serializeCollection($before, '', true);
        }
        if ($before !== null) {
            $queryParams['before'] = $before;
        }
        // query params
        if (is_array($assigned)) {
            $assigned = ObjectSerializer::serializeCollection($assigned, '', true);
        }
        if ($assigned !== null) {
            $queryParams['assigned'] = $assigned;
        }
        // query params
        if (is_array($created)) {
            $created = ObjectSerializer::serializeCollection($created, '', true);
        }
        if ($created !== null) {
            $queryParams['created'] = $created;
        }
        // query params
        if (is_array($mentioned)) {
            $mentioned = ObjectSerializer::serializeCollection($mentioned, '', true);
        }
        if ($mentioned !== null) {
            $queryParams['mentioned'] = $mentioned;
        }
        // query params
        if (is_array($reviewRequested)) {
            $reviewRequested = ObjectSerializer::serializeCollection($reviewRequested, '', true);
        }
        if ($reviewRequested !== null) {
            $queryParams['review_requested'] = $reviewRequested;
        }
        // query params
        if (is_array($owner)) {
            $owner = ObjectSerializer::serializeCollection($owner, '', true);
        }
        if ($owner !== null) {
            $queryParams['owner'] = $owner;
        }
        // query params
        if (is_array($team)) {
            $team = ObjectSerializer::serializeCollection($team, '', true);
        }
        if ($team !== null) {
            $queryParams['team'] = $team;
        }
        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueStartStopWatch
     *
     * Start stopwatch on an issue.
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to create the stopwatch on (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function issueStartStopWatch($owner, $repo, $index)
    {
        $this->issueStartStopWatchWithHttpInfo($owner, $repo, $index);
    }

    /**
     * Operation issueStartStopWatchWithHttpInfo
     *
     * Start stopwatch on an issue.
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to create the stopwatch on (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueStartStopWatchWithHttpInfo($owner, $repo, $index)
    {
        $request = $this->issueStartStopWatchRequest($owner, $repo, $index);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation issueStartStopWatchAsync
     *
     * Start stopwatch on an issue.
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to create the stopwatch on (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueStartStopWatchAsync($owner, $repo, $index)
    {
        return $this->issueStartStopWatchAsyncWithHttpInfo($owner, $repo, $index)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueStartStopWatchAsyncWithHttpInfo
     *
     * Start stopwatch on an issue.
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to create the stopwatch on (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueStartStopWatchAsyncWithHttpInfo($owner, $repo, $index)
    {
        $returnType = '';
        $request = $this->issueStartStopWatchRequest($owner, $repo, $index);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueStartStopWatch'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to create the stopwatch on (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueStartStopWatchRequest($owner, $repo, $index)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueStartStopWatch'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueStartStopWatch'
            );
        }
        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling issueStartStopWatch'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/{index}/stopwatch/start';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueStopStopWatch
     *
     * Stop an issue&#39;s existing stopwatch.
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to stop the stopwatch on (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function issueStopStopWatch($owner, $repo, $index)
    {
        $this->issueStopStopWatchWithHttpInfo($owner, $repo, $index);
    }

    /**
     * Operation issueStopStopWatchWithHttpInfo
     *
     * Stop an issue&#39;s existing stopwatch.
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to stop the stopwatch on (required)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function issueStopStopWatchWithHttpInfo($owner, $repo, $index)
    {
        $request = $this->issueStopStopWatchRequest($owner, $repo, $index);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation issueStopStopWatchAsync
     *
     * Stop an issue&#39;s existing stopwatch.
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to stop the stopwatch on (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueStopStopWatchAsync($owner, $repo, $index)
    {
        return $this->issueStopStopWatchAsyncWithHttpInfo($owner, $repo, $index)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueStopStopWatchAsyncWithHttpInfo
     *
     * Stop an issue&#39;s existing stopwatch.
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to stop the stopwatch on (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueStopStopWatchAsyncWithHttpInfo($owner, $repo, $index)
    {
        $returnType = '';
        $request = $this->issueStopStopWatchRequest($owner, $repo, $index);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueStopStopWatch'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue to stop the stopwatch on (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueStopStopWatchRequest($owner, $repo, $index)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueStopStopWatch'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueStopStopWatch'
            );
        }
        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling issueStopStopWatch'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/{index}/stopwatch/stop';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueSubscriptions
     *
     * Get users who subscribed on an issue.
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\User[]
     */
    public function issueSubscriptions($owner, $repo, $index, $page = null, $limit = null)
    {
        list($response) = $this->issueSubscriptionsWithHttpInfo($owner, $repo, $index, $page, $limit);
        return $response;
    }

    /**
     * Operation issueSubscriptionsWithHttpInfo
     *
     * Get users who subscribed on an issue.
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\User[], HTTP status code, HTTP response headers (array of strings)
     */
    public function issueSubscriptionsWithHttpInfo($owner, $repo, $index, $page = null, $limit = null)
    {
        $request = $this->issueSubscriptionsRequest($owner, $repo, $index, $page, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Efsa\Client\Gitea\Model\User[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\User[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\User[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\User[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueSubscriptionsAsync
     *
     * Get users who subscribed on an issue.
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueSubscriptionsAsync($owner, $repo, $index, $page = null, $limit = null)
    {
        return $this->issueSubscriptionsAsyncWithHttpInfo($owner, $repo, $index, $page, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueSubscriptionsAsyncWithHttpInfo
     *
     * Get users who subscribed on an issue.
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueSubscriptionsAsyncWithHttpInfo($owner, $repo, $index, $page = null, $limit = null)
    {
        $returnType = '\Efsa\Client\Gitea\Model\User[]';
        $request = $this->issueSubscriptionsRequest($owner, $repo, $index, $page, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueSubscriptions'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueSubscriptionsRequest($owner, $repo, $index, $page = null, $limit = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueSubscriptions'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueSubscriptions'
            );
        }
        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling issueSubscriptions'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/{index}/subscriptions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation issueTrackedTimes
     *
     * List an issue&#39;s tracked times
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  string $user optional filter by user (available for issue managers) (optional)
     * @param  \DateTime $since Only show times updated after the given time. This is a timestamp in RFC 3339 format (optional)
     * @param  \DateTime $before Only show times updated before the given time. This is a timestamp in RFC 3339 format (optional)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Efsa\Client\Gitea\Model\TrackedTime[]
     */
    public function issueTrackedTimes($owner, $repo, $index, $user = null, $since = null, $before = null, $page = null, $limit = null)
    {
        list($response) = $this->issueTrackedTimesWithHttpInfo($owner, $repo, $index, $user, $since, $before, $page, $limit);
        return $response;
    }

    /**
     * Operation issueTrackedTimesWithHttpInfo
     *
     * List an issue&#39;s tracked times
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  string $user optional filter by user (available for issue managers) (optional)
     * @param  \DateTime $since Only show times updated after the given time. This is a timestamp in RFC 3339 format (optional)
     * @param  \DateTime $before Only show times updated before the given time. This is a timestamp in RFC 3339 format (optional)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \Efsa\Client\Gitea\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Efsa\Client\Gitea\Model\TrackedTime[], HTTP status code, HTTP response headers (array of strings)
     */
    public function issueTrackedTimesWithHttpInfo($owner, $repo, $index, $user = null, $since = null, $before = null, $page = null, $limit = null)
    {
        $request = $this->issueTrackedTimesRequest($owner, $repo, $index, $user, $since, $before, $page, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Efsa\Client\Gitea\Model\TrackedTime[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Efsa\Client\Gitea\Model\TrackedTime[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Efsa\Client\Gitea\Model\TrackedTime[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Efsa\Client\Gitea\Model\TrackedTime[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation issueTrackedTimesAsync
     *
     * List an issue&#39;s tracked times
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  string $user optional filter by user (available for issue managers) (optional)
     * @param  \DateTime $since Only show times updated after the given time. This is a timestamp in RFC 3339 format (optional)
     * @param  \DateTime $before Only show times updated before the given time. This is a timestamp in RFC 3339 format (optional)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueTrackedTimesAsync($owner, $repo, $index, $user = null, $since = null, $before = null, $page = null, $limit = null)
    {
        return $this->issueTrackedTimesAsyncWithHttpInfo($owner, $repo, $index, $user, $since, $before, $page, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation issueTrackedTimesAsyncWithHttpInfo
     *
     * List an issue&#39;s tracked times
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  string $user optional filter by user (available for issue managers) (optional)
     * @param  \DateTime $since Only show times updated after the given time. This is a timestamp in RFC 3339 format (optional)
     * @param  \DateTime $before Only show times updated before the given time. This is a timestamp in RFC 3339 format (optional)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function issueTrackedTimesAsyncWithHttpInfo($owner, $repo, $index, $user = null, $since = null, $before = null, $page = null, $limit = null)
    {
        $returnType = '\Efsa\Client\Gitea\Model\TrackedTime[]';
        $request = $this->issueTrackedTimesRequest($owner, $repo, $index, $user, $since, $before, $page, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'issueTrackedTimes'
     *
     * @param  string $owner owner of the repo (required)
     * @param  string $repo name of the repo (required)
     * @param  int $index index of the issue (required)
     * @param  string $user optional filter by user (available for issue managers) (optional)
     * @param  \DateTime $since Only show times updated after the given time. This is a timestamp in RFC 3339 format (optional)
     * @param  \DateTime $before Only show times updated before the given time. This is a timestamp in RFC 3339 format (optional)
     * @param  int $page page number of results to return (1-based) (optional)
     * @param  int $limit page size of results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function issueTrackedTimesRequest($owner, $repo, $index, $user = null, $since = null, $before = null, $page = null, $limit = null)
    {
        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling issueTrackedTimes'
            );
        }
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling issueTrackedTimes'
            );
        }
        // verify the required parameter 'index' is set
        if ($index === null || (is_array($index) && count($index) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $index when calling issueTrackedTimes'
            );
        }

        $resourcePath = '/repos/{owner}/{repo}/issues/{index}/times';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($user)) {
            $user = ObjectSerializer::serializeCollection($user, '', true);
        }
        if ($user !== null) {
            $queryParams['user'] = $user;
        }
        // query params
        if (is_array($since)) {
            $since = ObjectSerializer::serializeCollection($since, '', true);
        }
        if ($since !== null) {
            $queryParams['since'] = $since;
        }
        // query params
        if (is_array($before)) {
            $before = ObjectSerializer::serializeCollection($before, '', true);
        }
        if ($before !== null) {
            $queryParams['before'] = $before;
        }
        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }
        // query params
        if (is_array($limit)) {
            $limit = ObjectSerializer::serializeCollection($limit, '', true);
        }
        if ($limit !== null) {
            $queryParams['limit'] = $limit;
        }


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($index !== null) {
            $resourcePath = str_replace(
                '{' . 'index' . '}',
                ObjectSerializer::toPathValue($index),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('access_token');
        if ($apiKey !== null) {
            $queryParams['access_token'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Sudo');
        if ($apiKey !== null) {
            $headers['Sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sudo');
        if ($apiKey !== null) {
            $queryParams['sudo'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-GITEA-OTP');
        if ($apiKey !== null) {
            $headers['X-GITEA-OTP'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('token');
        if ($apiKey !== null) {
            $queryParams['token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
